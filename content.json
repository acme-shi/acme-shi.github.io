{"meta":{"title":"凌云的个人博客","subtitle":null,"description":"凌云的博客","author":"凌云","url":"http://www.shifeiqi.top","root":"/"},"pages":[{"title":"WHO I AM","date":"2019-03-02T11:28:31.770Z","updated":"2019-03-02T11:28:31.770Z","comments":false,"path":"about/index.html","permalink":"http://www.shifeiqi.top/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-02T07:11:15.458Z","updated":"2019-03-02T07:11:15.458Z","comments":false,"path":"categories/index.html","permalink":"http://www.shifeiqi.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-02T07:10:51.430Z","updated":"2019-03-02T07:10:51.430Z","comments":false,"path":"tags/index.html","permalink":"http://www.shifeiqi.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"冒泡排序","slug":"2020-01-31-bubble-sort","date":"2019-02-11T07:58:00.000Z","updated":"2019-03-02T12:13:38.905Z","comments":true,"path":"2019/02/11/2020-01-31-bubble-sort/","link":"","permalink":"http://www.shifeiqi.top/2019/02/11/2020-01-31-bubble-sort/","excerpt":"","text":"💣 原理 冒泡排序基本思想： 将待排序队列分为未排序子队列（位于左侧，初始值为待排序队列）和已排序子队列（位于右侧，初始值为空）。 走访未排序子队列，选择未排序子队列中的最大值交换到未排序子队列的列尾。 未排序子队列长度减一， 已排序子队列长度加一。 未排序子队列长度 == 0 ? 排序结束 ： 重复第2步。 时间复杂度：O(n^2)。 稳定。 🔫 示例 以下是对队列 [4, 2, 3, 6, 8, 1, 5] 进行冒泡排序的模拟过程（注：算法抽象过程描述，非程序运行过程）。1234567891011121314151617181920212223242526272829300 [4, 2, 3, 6, 8, 1, 5 ] [ 未排序子队列 ] [已排序子队列] // 将待排序队列分为 [未排序子队列] 和 [已排序子队列]------------------------------------------------------------------------------------1 [4, 2, 3, 6, 1, 5, 8] [ 未排序子队列 ] [已排序子队列] //第1次走访， //选取当前未排序子队列中最大值8冒泡到最后------------------------------------------------------------------------------------2 [4, 2, 3, 1, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第2次走访， //选取当前未排序子队列中最大值6冒泡到最后------------------------------------------------------------------------------------3 [4, 2, 3, 1, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第3次走访， //选取当前未排序子队列中最大值5冒泡到最后------------------------------------------------------------------------------------4 [ 2, 3, 1, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第4次走访， //选取当前未排序子队列中最大值4冒泡到最后------------------------------------------------------------------------------------5 [ 2, 1, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第5次走访， //选取当前未排序子队列中最大值3冒泡到最后------------------------------------------------------------------------------------ 6 [ 1, 2, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第6次走访， //选取当前未排序子队列中最大值2冒泡到最后------------------------------------------------------------------------------------ 7 [ 1, 2, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第7次走访， //选取当前未排序子队列中最大值1冒泡到最后 🔪 算法实现 Java实现 123456789101112131415161718// swapprivate void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// sort interfacepublic int[] bubbleSort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); // bubble sort for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &gt; array[j + 1]) swap(array, j, j + 1); &#125; &#125; return array;&#125; JavaScript实现 1234567891011121314151617// swapconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// sort interfaceconst bubbleSort = nums =&gt; &#123; const array = nums.slice(); // bubble sort for(let i = 0; i &lt; array.length; i++) &#123; for(let j = 0; j &lt; array.length - i - 1; j++) if(array[j] &gt; array[j + 1]) swap(array, j, j + 1); &#125; return array;&#125;","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]}]}