{"meta":{"title":"凌云的个人博客","subtitle":null,"description":"凌云的博客","author":"凌云","url":"http://www.shifeiqi.top","root":"/"},"pages":[{"title":"WHO I AM","date":"2019-03-02T11:28:31.770Z","updated":"2019-03-02T11:28:31.770Z","comments":false,"path":"about/index.html","permalink":"http://www.shifeiqi.top/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-02T07:11:15.458Z","updated":"2019-03-02T07:11:15.458Z","comments":false,"path":"categories/index.html","permalink":"http://www.shifeiqi.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-02T07:10:51.430Z","updated":"2019-03-02T07:10:51.430Z","comments":false,"path":"tags/index.html","permalink":"http://www.shifeiqi.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"枚举对象属性","slug":"2019-05-12-enumerate_properties","date":"2019-05-12T09:09:00.000Z","updated":"2019-05-12T12:47:50.768Z","comments":true,"path":"2019/05/12/2019-05-12-enumerate_properties/","link":"","permalink":"http://www.shifeiqi.top/2019/05/12/2019-05-12-enumerate_properties/","excerpt":"","text":"写在前面在日常开发，尤其是类库的开发过程中，遍历对象属性是一项经常使用的操作。本文将介绍如何遍历对象自身可枚举属性、遍历对象自身全部属性、遍历对象全部可枚举属性、遍历对象全部属性 四方面的内容。 遍历对象自身可枚举属性使用接口 Object.keys(obj)JavaScript 提供内置接口 Object.keys(obj) 用来获取对象自身的（非继承）、可枚举的属性名称集合。 123456789'use strict'var o = &#123; a : 1, b : 'bran'&#125;// 获取对象自身可枚举属性，并遍历打印Object.keys(o).forEach(key =&gt; console.log(key, o[key])); 详见：Object​.keys() 。 使用接口 Object.values(obj)JavaScript 提供内置接口 Object.values(obj) 用来获取对象自身的（非继承）、可枚举的属性值集合。 123456789'use strict'var o = &#123; a : 1, b : 'bran'&#125;// 获取对象自身可枚举属性值集合Object.values(o).forEach(val =&gt; console.log(val)); 详见：Object​.values()。 使用接口 Object.entries()JavaScript 提供内置接口 Object.entries(obj) 用来获取对象自身的（非继承）、可枚举的键值对集合。 123456789'use strict'var o = &#123; a : 1, b : 'bran'&#125;// 获取对象自身可枚举属性的键值对集合Object.entries(o).forEach(entry =&gt; console.log(entry[0], entry[1])); 详见：Object​.entries()； 使用接口 Object.getOwnPropertyNames(obj) 和 Object​.prototype​.property​IsEnumerable()接口 Object.getOwnPropertyNames(obj) 用于获取对象自身的（非继承）所有的（可枚举和不可枚举）属性名称集合。接口 Object​.prototype​.property​IsEnumerable() 用于判断对象自身的（非继承）某个属性是否为可枚举。 12345678910111213141516171819'use strict'var o = &#123; a : 1, b : 'bran'&#125;;// 为对象定义一个不可枚举属性 cObject.defineProperty(o, 'c', &#123; configurable : true, enumerable : false, value : 'sophia', writable : true&#125;);// 遍历对象自身所有属性Object.getOwnPropertyNames(o).forEach(name =&gt; &#123; // 将对象自身可枚举属性打印出来 o.propertyIsEnumerable(name) &amp;&amp; console.log(name, o[name]);&#125;); 详见：Object​.get​OwnProperty​Names()，Object​.prototype​.property​IsEnumerable()。 使用 for...in 和 接口 Object​.prototype​.hasOwnProperty(prop)for...in 用于遍历对象所有的（自身及继承）、可枚举的属性集合。接口 Object​.prototype​.hasOwnProperty(prop) 用于判断对象自身（非继承）是否拥有某个属性。 1234567891011121314151617181920'use strict'var o = &#123; a : 1, b : 'bran'&#125;;// 为对象定义一个不可枚举属性 cObject.defineProperty(o, 'c', &#123; configurable : true, enumerable : false, value : 'sophia', writable : true&#125;);var key;// 遍历对象所有可枚举属性for(key in o) &#123; // 将对象自身的属性打印出来 o.hasOwnProperty(key) &amp;&amp; console.log(key, o[key]);&#125; 详见：for…in，Object​.prototype​.has​OwnProperty()。 遍历对象自身所有属性遍历对象自身（非继承）所有属性主要使用JavaScript内置接口 Object.getOwnPropertyNames(obj)。接口 Object.getOwnPropertyNames(obj) 用于获取对象自身所有的（可枚举和不可枚举）属性名称集合。 12345678910111213141516'use strict'var o = &#123; a : 1, b : 'bran'&#125;;// 为对象定义一个不可枚举属性 cObject.defineProperty(o, 'c', &#123; configurable : true, enumerable : false, value : 'sophia', writable : true&#125;);// 遍历对象自身所有属性，并将其打印出来Object.getOwnPropertyNames(o).forEach(key =&gt; console.log(key, o[key])); 详见：Object​.get​OwnProperty​Names()。 遍历对象所有可枚举属性（自身和继承）使用 for...inJavaScript中使用 for..in 来遍历对象所有的可枚举属性（自身和继承）。 123456789101112131415161718'use strict'var o = &#123; a : 1, b : 'bran'&#125;;// 为对象定义一个不可枚举属性 cObject.defineProperty(o, 'c', &#123; configurable : true, enumerable : false, value : 'sophia', writable : true&#125;);// 遍历对象所有可枚举属性var key;for(key in o) console.log(key, o[key]); 详见：for…in。 通过遍历原型链的方式通过遍历原型链，然后在每一个原型对象上获取可枚举属性的方式来获取对象所有的可枚举属性。 123456789101112131415161718192021'use strict'var o = &#123; a : 1, b : 'bran'&#125;;// 为对象定义一个不可枚举属性 cObject.defineProperty(o, 'c', &#123; configurable : true, enumerable : false, value : 'sophia', writable : true&#125;);var currentObj = o;while(currentObj) &#123; // 遍历原型链上当前对象自身可枚举属性 Object.keys(currentObj).forEach(key =&gt; console.log(key, currentObj[key])); // 迭代原型 currentObj = Object.getPrototypeOf(currentObj);&#125; 详见：Object​.get​PrototypeOf()。 遍历对象所有属性（自身和继承）通过遍历原型链，然后在每一个原型对象上获取当前原型对象所有属性的方式来获取对象所有的属性。 123456789101112131415161718192021'use strict'var o = &#123; a : 1, b : 'bran'&#125;;// 为对象定义一个不可枚举属性 cObject.defineProperty(o, 'c', &#123; configurable : true, enumerable : false, value : 'sophia', writable : true&#125;);var currentObj = o;while(currentObj) &#123; // 遍历原型链上当前对象所有属性 Object.getOwnPropertyNames(currentObj).forEach(propName =&gt; console.log(propName, currentObj[propName])); // 迭代原型 currentObj = Object.getPrototypeOf(currentObj);&#125; 详见：Object​.get​PrototypeOf()。","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"ECMA","slug":"ECMA","permalink":"http://www.shifeiqi.top/tags/ECMA/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://www.shifeiqi.top/tags/ECMAScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.shifeiqi.top/tags/JavaScript/"}]},{"title":"属性描述符","slug":"2019-05-08-property_descriptors","date":"2019-05-08T07:35:00.000Z","updated":"2019-05-12T12:52:21.617Z","comments":true,"path":"2019/05/08/2019-05-08-property_descriptors/","link":"","permalink":"http://www.shifeiqi.top/2019/05/08/2019-05-08-property_descriptors/","excerpt":"","text":"属性描述符简介什么是属性描述符属性描述符(property descriptor)是JavaScript提供的内置对象，用来配置JavaScript对象属性，控制JavaScript对象属性的行为（如控制属性是否可配置，是否可枚举，是否可写等等）。属性描述符(property descriptor) 在JavaScript内部表现为一个JavaScript对象，具有明确的键值对。如下所示： 12345678// 一个对象 o , 具有属性 a // o.a 的属性描述符o : &#123; // 其中键名 configurable, enumerable, value, writable 是明确的，不可更改的 a : 1 &lt;--------------------------------- &#123;&#125; configurable ： true, enumerable : true, value : 1, writable : true &#125; 详见：Description 如何获取属性描述符JavaScript 提供内置接口 Object.getOwnPropertyDescriptor(obj, prop) 用于获取对象属性的属性描述符。1234567891011var o = &#123; a : 1&#125;;Object.getOwnPropertyDescriptor(o, 'a');// &#123;// configurable: true,// enumerable: true,// value: 1,// writable: true// &#125; 详见： Object​.get​OwnProperty​Descriptor() 属性描述符的分类JavaScript 提供两种属性描述符：数据描述符(data descriptor)和存取描述符(accessor descriptor)。 数据描述符(data descriptor)数据描述符用来描述属性值以及属性是否可配置、可枚举、可写，数据描述符的表现形式如下:1234567// 一个值为 1 的数据描述符示例&#123; configurable : true, enumerable : true, value : 1, writeable : true &#125; 其中，各个键值含义如下： configurable： 表明该属性是否可配置。属性可配置包含但不限于以下情况： 该属性是否可用指令delete删除。 该属性的属性描述符是否可修改，即通过接口 Object.defineProperty(obj, prop, descriptor) 修改属性描述符。 enumerable： 表明该属性是否可枚举。属性可枚举的情况包含但不限于以下： 通过接口 Object.keys(obj) 遍历对象自身可枚举属性。 通过接口 Object.values(obj) 遍历对象自身可枚举属性值。 通过接口 Object.entries(obj) 遍历对象自身可枚举属性。 通过 for (variable in object) {...} 遍历对象可枚举属性（自身属性与继承属性）。 value： 表明属性的当前值。 writable：表明属性是否可写。属性可写包含但不限于以下情况： 通过赋值语句为对象属性赋值，如 o.a = 2; 。 通过接口 Object.defineProperty(obj, prop, descriptor) 修改数据描述符元属性value。 为属性定义数据描述符为对象属性定义数据描述符有两种方式：默认定义、自定义。 默认定义数据描述符通过赋值操作为对象添加属性时，JavaScript会为该属性创建一个默认的数据描述符。通过这种方式创建的数据描述符的元属性value值与对象属性值保持一致，其余元属性值都为true，具体表现形式如下：123456789// 通过赋值操作创建的默认数据描述符// var o = &#123;&#125;;// o.a = 1;&#123; configurable : true, enumerable : true, value : 1, writeable : true &#125; 创建一个默认数据描述符的示例如下：12345678910111213141516171819202122232425262728// 为对象 o 添加属性 a b cvar o = &#123; a : 1&#125;;o.b = 'b value';o['c'] = false;Object.getOwnPropertyDescriptor(o, 'a');// &#123;// configurable: true,// enumerable: true,// value: 1,// writable: true// &#125;Object.getOwnPropertyDescriptor(o, 'b');// &#123;// configurable: true,// enumerable: true,// value: 'b value',// writable: true// &#125;Object.getOwnPropertyDescriptor(o, 'c');// &#123;// configurable: true,// enumerable: true,// value: false,// writable: true// &#125; 自定义数据描述符JavaScript 提供内置接口 Object.defineProperty(obj, prop, descriptor) 用于定义及修改属性描述符。使用该接口创建数据描述符时，若没有指定数据描述符某个元属性值，则这个元属性会取默认值，数据描述符各元属性默认值如下：123456&#123; configurable : false, enumerable : false, value : undefined, writeable : false &#125; 使用接口 Object.defineProperty(obj, prop, descriptor) 定义数据描述符示例如下：12345678910111213141516171819202122232425262728293031'use strict'var o = &#123;&#125;;// 1. 定义属性 a, 并指定其为不可写属性Object.defineProperty(o, 'a', &#123; configurable : true, enumerable : true, value : 1, writable : false // 不可写&#125;);Object.getOwnPropertyDescriptor(o, 'a'); // &#123; // configurable: true, // enumerable: true, // value: 1, // writable: false // &#125; o.a = 2; // TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'// 2. 定义属性 b, 数据描述符元数据 value='b-value', writable=true, configurable和enumerable采用默认配置。Object.defineProperty(o, 'b', &#123; value : 'b-value', writable : true&#125;);Object.getOwnPropertyDescriptor(o, 'b'); // &#123; // configurable: false, // enumerable: false, // value: 'b-value', // writable: true // &#125;o.b = 'hi, Sophia'; // bingo 使用接口 Object.defineProperty(obj, prop, descriptor) 修改数据描述符示例如下：123456789101112131415161718192021222324252627282930'use strict'var o = &#123;&#125;;// 1. 定义属性 a, 并指定其为不可写属性Object.defineProperty(o, 'a', &#123; configurable : true, enumerable : true, value : 1, writable : false // 不可写&#125;);Object.getOwnPropertyDescriptor(o, 'a'); // &#123; // configurable: true, // enumerable: true, // value: 1, // writable: false // &#125;o.a = 2; // TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'// 2. 修改属性 a 的数据描述符，使其变为可写属性Object.defineProperty(o, 'a', &#123; writable : true&#125;);Object.getOwnPropertyDescriptor(o, 'a'); // &#123; // configurable: true, // enumerable: true, // value: 1, // writable: true // &#125;o.a = 2; // bingo 存取描述符(accessor descriptor)存取描述符用来描述对象属性是否可配置、可枚举，以及对属性的赋值及取值过程进行控制，存取描述符的一般结构如下： 1234567891011&#123; configurable : true, enumerable : true, get : function() &#123; // 返回值 return undefined; &#125;, set : function(val) &#123; // 赋值之前的逻辑操作 &#125;&#125; 其中，存取描述符的各个元属性含义如下： configurable： 表明该属性是否可配置。属性可配置包含但不限于以下情况： 该属性是否可用指令delete删除。 该属性的属性描述符是否可修改，即通过接口 Object.defineProperty(obj, prop, descriptor) 修改属性描述符。 enumerable： 表明该属性是否可枚举。属性可枚举的情况包含但不限于以下： 通过接口 Object.keys(obj) 遍历对象自身可枚举属性。 通过接口 Object.values(obj) 遍历对象自身可枚举属性值。 通过接口 Object.entries(obj) 遍历对象自身可枚举属性。 通过 for (variable in object) {...} 遍历对象可枚举属性（自身属性与继承属性）。 get : 该元属性只能取值为 undefined 或者 function 类型。 get 元属性值为 undefined 类型时，对象属性的取值操作返回值都是 undefined。 get 元属性值为 function 类型时，对象属性的取值操作返回值是该函数的返回值。 set : 该元属性只能取值 undefined 或者 function 类型。 set 元属性值为 undefined 类型时，对象属性赋值操作等于无效，严格模式下会抛异常。 set 元属性值为 function 类型时， 对象属性的赋值操作会调用该元属性函数。 为属性定义存取描述符存取描述符只能通过接口 Object.defineProperty(obj, prop, descriptor) 定义及修改。在定义存取描述符时可以指定少量的元属性，其余的存取描述符元属性将会采用默认值，存取描述符的元属性默认值如下： 123456&#123; configurable: false, enumerable: false, set : undefined, get : undefined&#125; 使用接口 Object.defineProperty(obj, prop, descriptor) 定义存取描述符的示例如下:12345678910111213141516171819202122232425262728'use strict'/** * 为 o.a 定义存取描述符，使得 o._a 与 o.a 保持数据同步 */var o = &#123;&#125;;o._a = undefined;// 为 o.a 定义存取描述符，configurable和enumerable采用默认值Object.defineProperty(o, 'a', &#123; get : function() &#123; return o._a; &#125;, set : function(val) &#123; o._a = val; &#125;&#125;);Object.getOwnPropertyDescriptor(o, 'a'); // &#123; // configurable: false, // enumerable: false, // get: [Function: get], // set: [Function: set] // &#125;o.a = 1; // o.a = 1, o._a = 1o.a; // 1o._a; // 1 使用接口 Object.defineProperty(obj, prop, descriptor) 修改存取描述符的示例如下:123456789101112131415161718192021222324252627282930313233343536373839404142'use strict'/** * 为 o.a 定义存取描述符，使得 o._a 与 o.a 保持数据同步 */var o = &#123;&#125;;o._a = undefined;// 为 o.a 定义存取描述符Object.defineProperty(o, 'a', &#123; configurable : true, enumerable : true, get : function() &#123; return o._a; &#125;, set : function(val) &#123; o._a = val; &#125;&#125;);Object.getOwnPropertyDescriptor(o, 'a'); // &#123; // configurable: true, // enumerable: true, // get: [Function: get], // set: [Function: set] // &#125;o.a = 1; // o.a = 1, o._a = 1o.a; // 1o._a; // 1// 修改 o.a 存取描述符， 使其变为不可枚举属性Object.defineProperty(o, 'a', &#123; enumerable : false&#125;);Object.getOwnPropertyDescriptor(o , 'a'); // &#123; // configurable: true, // enumerable: false, // get: [Function: get], // set: [Function: set] // &#125; 数据描述符与存取描述符的异同 数据描述符和存取描述符都具有元属性 configurable 和 enumerable, 且这两个元属性在数据描述符和存取描述符中的含义一致。 数据描述符的元属性集合只能是 [configurable， enumerable， value， writable]。 存取描述符的元属性集合只能是 [configurable， enumerable，set， get]。 参考 Object​.get​OwnProperty​Descriptor(); Object​.get​OwnProperty​Descriptors(); Object​.define​Property(); Object​.keys(); Object​.values(); Object​.entries(); for…in;","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"ECMA","slug":"ECMA","permalink":"http://www.shifeiqi.top/tags/ECMA/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://www.shifeiqi.top/tags/ECMAScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.shifeiqi.top/tags/JavaScript/"}]},{"title":"选择排序","slug":"2019-03-11-select-sort","date":"2019-03-11T11:33:00.000Z","updated":"2019-05-10T11:40:57.506Z","comments":true,"path":"2019/03/11/2019-03-11-select-sort/","link":"","permalink":"http://www.shifeiqi.top/2019/03/11/2019-03-11-select-sort/","excerpt":"","text":"🍎原理将待排序序列划分为 已排序序列 和 未排序序列，对 待排序序列 进行 N - 1 次遍历排序，每次遍历排序的过程如下： 从 未排序序列 中选择一个最小值 min。 将最小值插 min 入到 已排序序列 队尾，已排序序列长度加1， 未排序序列长度减1。 时间复杂度: O(n^2)稳定排序算法🍊示例以下示例对序列 [3, 2, 5, 7, 4, 1, 9, 8, 6] 进行排序过程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566670x00 从未排序队列中 [3, 2, 5, 7, 4, 1, 9, 8, 6] 选择最小值 1 加入到已排序队列 [] 中 [已排序][未排序-------------------] [3, 2, 5, 7, 4, 1, 9, 8, 6] ^min----------------------------------------------------------------0x01 从未排序队列[3, 2, 5, 7, 4, 9, 8, 6]中选择最小值 2 加入到已排序队列 [1] 中 [已排序---][未排序----------------] [1, 3, 2, 5, 7, 4, 9, 8, 6] ^min----------------------------------------------------------------0x02 从未排序队列[3, 5, 7, 4, 9, 8, 6]中选择最小值 3 加入到已排序队列 [1,2] 中 [已排序------][未排序-------------] [1, 2, 3, 5, 7, 4, 9, 8, 6] ^min----------------------------------------------------------------0x03 从未排序队列[5, 7, 4, 9, 8, 6]中选择最小值 4 加入到已排序队列 [1,2,3] 中 [已排序---------][未排序----------] [1, 2, 3, 5, 7, 4, 9, 8, 6] ^min----------------------------------------------------------------0x04 从未排序队列[7, 5, 9, 8, 6]中选择最小值 5 加入到已排序队列 [1,2,3,4] 中 [已排序-----------][未排序-------] [1, 2, 3, 4, 7, 5, 9, 8, 6] ^min----------------------------------------------------------------0x05 从未排序队列中[7, 9, 8, 6]选择最小值 6 加入到已排序队列 [1,2,3,4,5] 中 [已排序--------------][未排序----] [1, 2, 3, 4, 5, 7, 9, 8, 6] ^min----------------------------------------------------------------0x06 从未排序队列中[9, 8, 7]选择最小值 7 加入到已排序队列 [1,2,3,4,5,6] 中 [已排序-----------------][未排序-] [1, 2, 3, 4, 5, 6, 9, 8, 7] ^min----------------------------------------------------------------0x07 从未排序队列[8, 9]中选择最小值 8 加入到已排序队列 [1,2,3,4,5,6,7] 中 [已排序--------------------][未排序] [1, 2, 3, 4, 5, 6, 7, 8, 9] ^min----------------------------------------------------------------0x08 从未排序队列[9]中选择最小值 9 加入到已排序队列 [1,2,3,4,5,6,7,8] 中 [已排序-----------------------][未排序] [1, 2, 3, 4, 5, 6, 7, 8, 9] ^min----------------------------------------------------------------0x09 game over! [已排序--------------------------][未排序] [1, 2, 3, 4, 5, 6, 7, 8, 9] 🍋实现Java实现12345678910111213141516171819202122// swap funcpublic void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// interface: select sortpublic int[] selectSort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); for(int i = 0 ; i &lt; array.length; i++) &#123; int minIndex = i; for(int j = i + 1; j &lt; array.length; j++) &#123; if(array[minIndex] &gt; array[j]) minIndex = j; &#125; swap(array, i, minIndex); &#125; return array;&#125; JavaScript实现1234567891011121314151617181920212223242526// swapconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex] array[lIndex] = array[rIndex] array[rIndex] = tmp&#125;// interface: shell sortconst selectSort = (nums) =&gt; &#123; const array = nums.map(e =&gt; e) for(let i = 0; i &lt; array.length; i++) &#123; let minIndex = i for(let j = i + 1; j &lt; array.length; j++) &#123; if(array[minIndex] &gt; array[j]) minIndex = j &#125; swap(array, i, minIndex) &#125; return array&#125;// testconst nums = [123,12,3,5,62,2,67,234,234,234,12,1]const ret = selectSort(nums)console.log('ret', ret)","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]},{"title":"希尔排序","slug":"2019-03-07-shell-sort","date":"2019-03-07T14:04:00.000Z","updated":"2019-03-07T14:13:29.065Z","comments":true,"path":"2019/03/07/2019-03-07-shell-sort/","link":"","permalink":"http://www.shifeiqi.top/2019/03/07/2019-03-07-shell-sort/","excerpt":"","text":"🌍原理基本原理希尔排序在直接插入排序上提出了增量 d 的概念，希尔排序过程如下： 把序列分为 d 个组，下标相距为 d 的倍数的元素放到同一个组中（d一般初始值为序列长度的一半）。 123456对于队列 [1, 6, 2, 3, 7, 5, 9, 8, 4], 设增量 d = 3, 则分组情况如下： [1, 6, 2, 3, 7, 5, 9, 8, 4] 1组 2组 3组 1组 2组 3组 1组 2组 3组即上述序列分成 3 个组：[1,3,9], [6,7,8], [2,5,4] 对所有的分组进行直接插入排序。 d = d / 2，执行第 1 步，直到 d = 0。 时间复杂度(n^1.3)不稳定排序算法🌎示例以下示例对队列 [1, 6, 2, 3, 7, 5, 9, 8, 4] 进行希尔排序过程：12345678910111213141516171819202122232425262728293031320x00 增量 d = 9 / 2 = 4, 分组情况如下： [1, 6, 2, 3, 7, 5, 9, 8, 4] 1组 2组 3组 4组 1组 2组 3组 4组 1组------------------------------------------------------------0x01 增量 d = 4, 对个分组进行直接插入排序。 [1, 5, 2, 3, 4, 6, 9, 8, 7] 1组 2组 3组 4组 1组 2组 3组 4组 1组------------------------------------------------------------0x03 增量 d = d / 2 = 4 / 2 = 2, 分组情况如下： [1, 5, 2, 3, 4, 6, 9, 8, 7] 1组 2组 1组 2组 1组 2组 1组 2组 1组------------------------------------------------------------0x04 增量 d = 2，对各分组进行直接插入排序。 [1, 3, 2, 5, 4, 6, 7, 8, 9] 1组 2组 1组 2组 1组 2组 1组 2组 1组------------------------------------------------------------0x05 增量 d = d / 2 = 2 / 2 = 1, 分组情况如下： [1, 3, 2, 5, 4, 6, 7, 8, 9] 1组 1组 1组 1组 1组 1组 1组 1组 1组------------------------------------------------------------0x06 增量 d = 1, 对个分组进行直接插入排序。 [1, 2, 3, 4, 5, 6, 7, 8, 9] 1组 1组 1组 1组 1组 1组 1组 1组 1组------------------------------------------------------------0x07 增量 d = d / 2 = 1 / 2 = 0, 结束排序。 [1, 2, 3, 4, 5, 6, 7, 8, 9] 🌏实现Java实现1234567891011121314151617181920212223// swap funcpublic void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// interface: shell sortpublic int[] shellSort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); for(int d = array.length / 2; d &gt; 0; d /= 2) &#123; for(int i = 0 ; i &lt; array.length; i += d) &#123; for(int j = i; j &gt; 0; j -= d) &#123; if(array[j - d] &gt; array[j]) swap(array, j - d, j); else break; &#125; &#125; &#125; return array;&#125; JavaScript实现123456789101112131415161718192021222324252627// swapconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex] array[lIndex] = array[rIndex] array[rIndex] = tmp&#125;// interface: shell sortconst shellSort = (nums) =&gt; &#123; const array = nums.map(e =&gt; e) for(let d = Math.floor(array.length / 2); d &gt; 0; d = Math.floor(d / 2)) &#123; for(let i = 0; i &lt; array.length; i ++) &#123; for(let j = i; j &gt; d - 1; j -= d) &#123; if(array[j - d] &gt; array[j]) swap(array, j - d, j) else break &#125; &#125; &#125; return array&#125;// testconst nums = [123,12,3,5,62,2,67,234,234,234,12,1]const ret = shellSort(nums)console.log('ret', ret)","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]},{"title":"直接插入排序","slug":"2019-03-06-insert-sort","date":"2019-03-06T12:24:00.000Z","updated":"2019-03-06T12:26:58.339Z","comments":true,"path":"2019/03/06/2019-03-06-insert-sort/","link":"","permalink":"http://www.shifeiqi.top/2019/03/06/2019-03-06-insert-sort/","excerpt":"","text":"🌒原理基本原理将序列分为两部分：已排序序列和未排序序列,每次遍历队列都会做以下操作： 从未排序队列中取一个值(一般取队列头元素或尾元素)。 将取到的值插入到已排序队列的正确位置。 时间复杂度: O(n^2)稳定性排序算法🌓示例以下模拟对 [3, 2, 5, 7, 1, 8, 9, 4, 6] 进行插入排序过程:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556570x00 选取3插入到已排序队列中 [已排序][未排序--------------------] [3, 2, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x01 选取2插入到已排序队列中 [已排序][未排序----------------] [3, 2, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x02 选取5插入到已排序队列中 [已排序][未排序-------------] [2, 3, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x03 选取7插入到已排序队列中 [已排序--][未排序----------] [2, 3, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x04 选取1插入到已排序队列中 [已排序-----][未排序-------] [2, 3, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x05 选取8插入到已排序队列中 [已排序--------][未排序----] [1, 2, 3, 5, 7, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x06 选取9插入到已排序队列中 [已排序-----------][未排序-] [1, 2, 3, 5, 7, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x07 选取4插入到已排序队列中 [已排序--------------][未排序] [1, 2, 3, 5, 7, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x08 选取6插入到已排序队列中 [已排序--------------][未排序] [1, 2, 3, 4, 5, 7, 8, 9, 6] ^------------------------------------------------------------------------------0x09 排序完成 [已排序------------------ -][未排序] [1, 2, 3, 4, 5, 6, 7, 8, 9] 🌔实现Java实现123456789101112131415161718192021//swap func private void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp; &#125; // interface: insert sort func public int[] insertSort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); for(int i = 0; i &lt; array.length; i++) &#123; for(int j = i; j &gt; 0; j--) &#123; if(array[j - 1] &gt; array[j]) swap(array, j - 1, j); else break; &#125; &#125; return array; &#125; JavaScript实现12345678910111213141516171819202122232425// swapconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex] array[lIndex] = array[rIndex] array[rIndex] = tmp&#125;// interface: insert sortconst insertSort = (nums) =&gt; &#123; const array = nums.map(e =&gt; e); for(let i = 0 ; i &lt; array.length; i++) &#123; for(let j = i; j &gt; 0; j--) &#123; if(array[j - 1] &gt; array[j]) swap(array, j - 1, j) else break &#125; &#125; return array&#125;// testconst nums = [123,12,3,5,62,2,67,234,234,234,12]const ret = insertSort(nums)console.log(ret)","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]},{"title":"快速排序","slug":"2019-03-05-quick-sort","date":"2019-03-05T11:24:00.000Z","updated":"2019-03-05T11:48:27.798Z","comments":true,"path":"2019/03/05/2019-03-05-quick-sort/","link":"","permalink":"http://www.shifeiqi.top/2019/03/05/2019-03-05-quick-sort/","excerpt":"","text":"🐶 原理基本思想 快速排序属于交换排序的一种，采用分治的思想， 步骤如下： 基准&lt;pivot&gt;选取: 从待排序序列中挑出一个元素，称之为”基准元素”(pivot)，一般选择队列中第一个元素或者最后一个元素。 分割&lt;partition&gt;操作：把所有比基准元素小的元素交换到基准元素前面，所有比基准元素大的元素交换到基准元素后面。 在 由基准元素分割得到的两个子队列 上分别执行第1步操作。 时间复杂度: O(nlogn)不稳定🐰 示例以下示例模拟对 [1, 6, 2, 8, 4, 3, 7, 9, 5] 进行快速排序过程, 基准选择序列的最后一个元素. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556570x00 [1, 6, 2, 8, 4, 3, 7, 9, 5] ^pivot // 队列[1,6,2,8,4,3,7,9,5]选取基准5,进行第一次递归分割----------------------------------------------------------------------------------------0x01 [----比5小-----] [----比5大-----] [1, 3, 2, 4, &lt;5&gt;, 8, 7, 9, 6] // 第一次递归分割结束,获得两个子队列 // 队列[1,6,2,8,4,3,7,9,5]被基准5分割为[1,3,2,4]和[8,7,9,6]----------------------------------------------------------------------------------------0x10 [ ] [ ] [1, 3, 2, 4, &lt;5&gt;, 8, 7, 9, 6] ^pivot ^pivot // 对待分割子队列[1,3,2,4]选取基准4,进入第二次递归分割, // 对待分割子队列[8,7,9,6]选取基准6,进入第二次递归分割----------------------------------------------------------------------------------------0x11 [--比4小--] [] [] [--比6大---] [1, 3, 2, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, 9, 8] // 第二次递归分割结束,获得四个子队列 // [1,3,2,4]被4分割为 [1,3,2] 和 [] // [8,7,9,6]被6分割为 [] 和 [7,9,6]----------------------------------------------------------------------------------------0x20 [ ] [] [] [ ] [1, 3, 2, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, 9, 8] ^pivot ^pivot // 子队列[1,3,2]选取基准2,进入第三次递归分割 // 子队列[7,9,8]选取基准8,进入第三次递归分割 // []不做处理----------------------------------------------------------------------------------------0x21 [-] [-] [-] [-] [1, &lt;2&gt;, 3, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, &lt;8&gt;, 9] // 第三次递归分割结束,获取4个子队列 // [1,3,2]被3分割为[1]和[3] // [7,9,8]被8分割为[7]和[9]----------------------------------------------------------------------------------------0x30 [-] [-] [-] [-] [1, &lt;2&gt;, 3, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, &lt;8&gt;, 9] ^pivot ^pivot ^pivot ^pivot // 子队列[1] [3] [7] [9] 都只包含一个基准元素,直接返回.----------------------------------------------------------------------------------------0x31 [&lt;1&gt;, &lt;2&gt;, &lt;3&gt;, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, &lt;7&gt;, &lt;8&gt;, &lt;9&gt;] // 获得排好队列 🐗 实现Java 递归实现12345678910111213141516171819202122232425262728293031323334353637383940// swap funcprivate void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// partition funcprivate int partition(int[] array, int left, int right) &#123; // 选取基准 int pivot = array[right]; int sIndex = right; // 分割 while(left &lt; right) &#123; while(array[left] &lt;= pivot &amp;&amp; left &lt; right) left ++; swap(array, left, sIndex); sIndex = left; // -- while(array[right] &gt;= pivot &amp;&amp; left &lt; right) right --; swap(array, sIndex, right); sIndex = right; &#125; return sIndex;&#125;// quick sort, recursively funcprivate void quickSort(int[] array, int left, int right) &#123; if(left &gt;= right) return; int parIndex = partition(array, left, right); // 递归 quickSort(array, left, parIndex - 1); quickSort(array, parIndex + 1, right);&#125;// sort interfacepublic int[] sort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); quickSort(array, 0, array.length - 1); return array;&#125; JavaScript 递归实现123456789101112131415161718192021222324252627282930313233343536373839// swap funcconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// partition funcconst partition = (array, left, right) =&gt; &#123; // 选择基准 const pivot = array[right]; let sIndex = right; // 分割 while(left &lt; right) &#123; while(array[left] &lt;= pivot &amp;&amp; left &lt; right) left++; swap(array, left, sIndex); sIndex = left; // while(array[right] &gt;= pivot &amp;&amp; left &lt; right) right--; swap(array, sIndex, right); sIndex = right; &#125; return sIndex;&#125;// quick sort, recursively funcconst quickSort = (array, left, right) =&gt; &#123; if(left &gt;= right) return; const parIndex = partition(array, left, right); quickSort(array, left, parIndex - 1); quickSort(array, parIndex + 1, right);&#125;// sort interface funcconst sort = (nums) =&gt; &#123; const array = nums.slice(); quickSort(array, 0, array.length - 1); return array;&#125;","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]},{"title":"冒泡排序","slug":"2019-02-11-bubble-sort","date":"2019-02-11T07:58:00.000Z","updated":"2019-03-06T12:23:27.452Z","comments":true,"path":"2019/02/11/2019-02-11-bubble-sort/","link":"","permalink":"http://www.shifeiqi.top/2019/02/11/2019-02-11-bubble-sort/","excerpt":"","text":"💣 原理冒泡排序基本思想： 将待排序队列分为未排序子队列（位于左侧，初始值为待排序队列）和已排序子队列（位于右侧，初始值为空）。 走访未排序子队列，选择未排序子队列中的最大值交换到未排序子队列的列尾。 未排序子队列长度减一， 已排序子队列长度加一。 未排序子队列长度 == 0 ? 排序结束 ： 重复第2步。 时间复杂度：O(n^2)。稳定性排序算法。🔫 示例 以下是对队列 [4, 2, 3, 6, 8, 1, 5] 进行冒泡排序的模拟过程（注：算法抽象过程描述，非程序运行过程）。1234567891011121314151617181920212223242526272829300 [4, 2, 3, 6, 8, 1, 5 ] [ 未排序子队列 ] [已排序子队列] // 将待排序队列分为 [未排序子队列] 和 [已排序子队列]------------------------------------------------------------------------------------1 [4, 2, 3, 6, 1, 5, 8] [ 未排序子队列 ] [已排序子队列] //第1次走访， //选取当前未排序子队列中最大值8冒泡到最后------------------------------------------------------------------------------------2 [4, 2, 3, 1, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第2次走访， //选取当前未排序子队列中最大值6冒泡到最后------------------------------------------------------------------------------------3 [4, 2, 3, 1, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第3次走访， //选取当前未排序子队列中最大值5冒泡到最后------------------------------------------------------------------------------------4 [ 2, 3, 1, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第4次走访， //选取当前未排序子队列中最大值4冒泡到最后------------------------------------------------------------------------------------5 [ 2, 1, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第5次走访， //选取当前未排序子队列中最大值3冒泡到最后------------------------------------------------------------------------------------ 6 [ 1, 2, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第6次走访， //选取当前未排序子队列中最大值2冒泡到最后------------------------------------------------------------------------------------ 7 [ 1, 2, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第7次走访， //选取当前未排序子队列中最大值1冒泡到最后 🔪 算法实现Java实现123456789101112131415161718// swapprivate void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// sort interfacepublic int[] bubbleSort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); // bubble sort for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &gt; array[j + 1]) swap(array, j, j + 1); &#125; &#125; return array;&#125; JavaScript实现1234567891011121314151617// swapconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// sort interfaceconst bubbleSort = nums =&gt; &#123; const array = nums.slice(); // bubble sort for(let i = 0; i &lt; array.length; i++) &#123; for(let j = 0; j &lt; array.length - i - 1; j++) if(array[j] &gt; array[j + 1]) swap(array, j, j + 1); &#125; return array;&#125;","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]}]}