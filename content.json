{"meta":{"title":"凌云的个人博客","subtitle":null,"description":"凌云的博客","author":"凌云","url":"http://www.shifeiqi.top","root":"/"},"pages":[{"title":"","date":"2019-03-02T07:11:15.458Z","updated":"2019-03-02T07:11:15.458Z","comments":false,"path":"categories/index.html","permalink":"http://www.shifeiqi.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-02T07:10:51.430Z","updated":"2019-03-02T07:10:51.430Z","comments":false,"path":"tags/index.html","permalink":"http://www.shifeiqi.top/tags/index.html","excerpt":"","text":""},{"title":"WHO I AM","date":"2019-03-02T11:28:31.770Z","updated":"2019-03-02T11:28:31.770Z","comments":false,"path":"about/index.html","permalink":"http://www.shifeiqi.top/about/index.html","excerpt":"","text":""}],"posts":[{"title":"直接插入排序","slug":"2019-03-06-insert-sort","date":"2019-03-06T12:24:00.000Z","updated":"2019-03-06T12:26:58.339Z","comments":true,"path":"2019/03/06/2019-03-06-insert-sort/","link":"","permalink":"http://www.shifeiqi.top/2019/03/06/2019-03-06-insert-sort/","excerpt":"","text":"🌒原理基本原理将序列分为两部分：已排序序列和未排序序列,每次遍历队列都会做以下操作： 从未排序队列中取一个值(一般取队列头元素或尾元素)。 将取到的值插入到已排序队列的正确位置。 时间复杂度: O(n^2)稳定性排序算法🌓示例以下模拟对 [3, 2, 5, 7, 1, 8, 9, 4, 6] 进行插入排序过程:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556570x00 选取3插入到已排序队列中 [已排序][未排序--------------------] [3, 2, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x01 选取2插入到已排序队列中 [已排序][未排序----------------] [3, 2, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x02 选取5插入到已排序队列中 [已排序][未排序-------------] [2, 3, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x03 选取7插入到已排序队列中 [已排序--][未排序----------] [2, 3, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x04 选取1插入到已排序队列中 [已排序-----][未排序-------] [2, 3, 5, 7, 1, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x05 选取8插入到已排序队列中 [已排序--------][未排序----] [1, 2, 3, 5, 7, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x06 选取9插入到已排序队列中 [已排序-----------][未排序-] [1, 2, 3, 5, 7, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x07 选取4插入到已排序队列中 [已排序--------------][未排序] [1, 2, 3, 5, 7, 8, 9, 4, 6] ^------------------------------------------------------------------------------0x08 选取6插入到已排序队列中 [已排序--------------][未排序] [1, 2, 3, 4, 5, 7, 8, 9, 6] ^------------------------------------------------------------------------------0x09 排序完成 [已排序------------------ -][未排序] [1, 2, 3, 4, 5, 6, 7, 8, 9] 🌔实现Java实现123456789101112131415161718192021//swap func private void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp; &#125; // interface: insert sort func public int[] insertSort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); for(int i = 0; i &lt; array.length; i++) &#123; for(int j = i; j &gt; 0; j--) &#123; if(array[j - 1] &gt; array[j]) swap(array, j - 1, j); else break; &#125; &#125; return array; &#125; JavaScript实现12345678910111213141516171819202122232425// swapconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex] array[lIndex] = array[rIndex] array[rIndex] = tmp&#125;// interface: insert sortconst insertSort = (nums) =&gt; &#123; const array = nums.map(e =&gt; e); for(let i = 0 ; i &lt; array.length; i++) &#123; for(let j = i; j &gt; 0; j--) &#123; if(array[j - 1] &gt; array[j]) swap(array, j - 1, j) else break &#125; &#125; return array&#125;// testconst nums = [123,12,3,5,62,2,67,234,234,234,12]const ret = insertSort(nums)console.log(ret)","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]},{"title":"快速排序","slug":"2019-03-05-quick-sort","date":"2019-03-05T11:24:00.000Z","updated":"2019-03-05T11:48:27.798Z","comments":true,"path":"2019/03/05/2019-03-05-quick-sort/","link":"","permalink":"http://www.shifeiqi.top/2019/03/05/2019-03-05-quick-sort/","excerpt":"","text":"🐶 原理基本思想 快速排序属于交换排序的一种，采用分治的思想， 步骤如下： 基准&lt;pivot&gt;选取: 从待排序序列中挑出一个元素，称之为”基准元素”(pivot)，一般选择队列中第一个元素或者最后一个元素。 分割&lt;partition&gt;操作：把所有比基准元素小的元素交换到基准元素前面，所有比基准元素大的元素交换到基准元素后面。 在 由基准元素分割得到的两个子队列 上分别执行第1步操作。 时间复杂度: O(nlogn)不稳定🐰 示例以下示例模拟对 [1, 6, 2, 8, 4, 3, 7, 9, 5] 进行快速排序过程, 基准选择序列的最后一个元素. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556570x00 [1, 6, 2, 8, 4, 3, 7, 9, 5] ^pivot // 队列[1,6,2,8,4,3,7,9,5]选取基准5,进行第一次递归分割----------------------------------------------------------------------------------------0x01 [----比5小-----] [----比5大-----] [1, 3, 2, 4, &lt;5&gt;, 8, 7, 9, 6] // 第一次递归分割结束,获得两个子队列 // 队列[1,6,2,8,4,3,7,9,5]被基准5分割为[1,3,2,4]和[8,7,9,6]----------------------------------------------------------------------------------------0x10 [ ] [ ] [1, 3, 2, 4, &lt;5&gt;, 8, 7, 9, 6] ^pivot ^pivot // 对待分割子队列[1,3,2,4]选取基准4,进入第二次递归分割, // 对待分割子队列[8,7,9,6]选取基准6,进入第二次递归分割----------------------------------------------------------------------------------------0x11 [--比4小--] [] [] [--比6大---] [1, 3, 2, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, 9, 8] // 第二次递归分割结束,获得四个子队列 // [1,3,2,4]被4分割为 [1,3,2] 和 [] // [8,7,9,6]被6分割为 [] 和 [7,9,6]----------------------------------------------------------------------------------------0x20 [ ] [] [] [ ] [1, 3, 2, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, 9, 8] ^pivot ^pivot // 子队列[1,3,2]选取基准2,进入第三次递归分割 // 子队列[7,9,8]选取基准8,进入第三次递归分割 // []不做处理----------------------------------------------------------------------------------------0x21 [-] [-] [-] [-] [1, &lt;2&gt;, 3, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, &lt;8&gt;, 9] // 第三次递归分割结束,获取4个子队列 // [1,3,2]被3分割为[1]和[3] // [7,9,8]被8分割为[7]和[9]----------------------------------------------------------------------------------------0x30 [-] [-] [-] [-] [1, &lt;2&gt;, 3, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, &lt;8&gt;, 9] ^pivot ^pivot ^pivot ^pivot // 子队列[1] [3] [7] [9] 都只包含一个基准元素,直接返回.----------------------------------------------------------------------------------------0x31 [&lt;1&gt;, &lt;2&gt;, &lt;3&gt;, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, &lt;7&gt;, &lt;8&gt;, &lt;9&gt;] // 获得排好队列 🐗 实现Java 递归实现12345678910111213141516171819202122232425262728293031323334353637383940// swap funcprivate void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// partition funcprivate int partition(int[] array, int left, int right) &#123; // 选取基准 int pivot = array[right]; int sIndex = right; // 分割 while(left &lt; right) &#123; while(array[left] &lt;= pivot &amp;&amp; left &lt; right) left ++; swap(array, left, sIndex); sIndex = left; // -- while(array[right] &gt;= pivot &amp;&amp; left &lt; right) right --; swap(array, sIndex, right); sIndex = right; &#125; return sIndex;&#125;// quick sort, recursively funcprivate void quickSort(int[] array, int left, int right) &#123; if(left &gt;= right) return; int parIndex = partition(array, left, right); // 递归 quickSort(array, left, parIndex - 1); quickSort(array, parIndex + 1, right);&#125;// sort interfacepublic int[] sort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); quickSort(array, 0, array.length - 1); return array;&#125; JavaScript 递归实现123456789101112131415161718192021222324252627282930313233343536373839// swap funcconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// partition funcconst partition = (array, left, right) =&gt; &#123; // 选择基准 const pivot = array[right]; let sIndex = right; // 分割 while(left &lt; right) &#123; while(array[left] &lt;= pivot &amp;&amp; left &lt; right) left++; swap(array, left, sIndex); sIndex = left; // while(array[right] &gt;= pivot &amp;&amp; left &lt; right) right--; swap(array, sIndex, right); sIndex = right; &#125; return sIndex;&#125;// quick sort, recursively funcconst quickSort = (array, left, right) =&gt; &#123; if(left &gt;= right) return; const parIndex = partition(array, left, right); quickSort(array, left, parIndex - 1); quickSort(array, parIndex + 1, right);&#125;// sort interface funcconst sort = (nums) =&gt; &#123; const array = nums.slice(); quickSort(array, 0, array.length - 1); return array;&#125;","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]},{"title":"冒泡排序","slug":"2019-02-11-bubble-sort","date":"2019-02-11T07:58:00.000Z","updated":"2019-03-06T12:23:27.452Z","comments":true,"path":"2019/02/11/2019-02-11-bubble-sort/","link":"","permalink":"http://www.shifeiqi.top/2019/02/11/2019-02-11-bubble-sort/","excerpt":"","text":"💣 原理冒泡排序基本思想： 将待排序队列分为未排序子队列（位于左侧，初始值为待排序队列）和已排序子队列（位于右侧，初始值为空）。 走访未排序子队列，选择未排序子队列中的最大值交换到未排序子队列的列尾。 未排序子队列长度减一， 已排序子队列长度加一。 未排序子队列长度 == 0 ? 排序结束 ： 重复第2步。 时间复杂度：O(n^2)。稳定性排序算法。🔫 示例 以下是对队列 [4, 2, 3, 6, 8, 1, 5] 进行冒泡排序的模拟过程（注：算法抽象过程描述，非程序运行过程）。1234567891011121314151617181920212223242526272829300 [4, 2, 3, 6, 8, 1, 5 ] [ 未排序子队列 ] [已排序子队列] // 将待排序队列分为 [未排序子队列] 和 [已排序子队列]------------------------------------------------------------------------------------1 [4, 2, 3, 6, 1, 5, 8] [ 未排序子队列 ] [已排序子队列] //第1次走访， //选取当前未排序子队列中最大值8冒泡到最后------------------------------------------------------------------------------------2 [4, 2, 3, 1, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第2次走访， //选取当前未排序子队列中最大值6冒泡到最后------------------------------------------------------------------------------------3 [4, 2, 3, 1, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第3次走访， //选取当前未排序子队列中最大值5冒泡到最后------------------------------------------------------------------------------------4 [ 2, 3, 1, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第4次走访， //选取当前未排序子队列中最大值4冒泡到最后------------------------------------------------------------------------------------5 [ 2, 1, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第5次走访， //选取当前未排序子队列中最大值3冒泡到最后------------------------------------------------------------------------------------ 6 [ 1, 2, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第6次走访， //选取当前未排序子队列中最大值2冒泡到最后------------------------------------------------------------------------------------ 7 [ 1, 2, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第7次走访， //选取当前未排序子队列中最大值1冒泡到最后 🔪 算法实现Java实现123456789101112131415161718// swapprivate void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// sort interfacepublic int[] bubbleSort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); // bubble sort for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &gt; array[j + 1]) swap(array, j, j + 1); &#125; &#125; return array;&#125; JavaScript实现1234567891011121314151617// swapconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// sort interfaceconst bubbleSort = nums =&gt; &#123; const array = nums.slice(); // bubble sort for(let i = 0; i &lt; array.length; i++) &#123; for(let j = 0; j &lt; array.length - i - 1; j++) if(array[j] &gt; array[j + 1]) swap(array, j, j + 1); &#125; return array;&#125;","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]}]}