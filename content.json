{"meta":{"title":"凌云的个人博客","subtitle":null,"description":"凌云的博客","author":"凌云","url":"http://www.shifeiqi.top","root":"/"},"pages":[{"title":"","date":"2019-03-02T07:11:15.458Z","updated":"2019-03-02T07:11:15.458Z","comments":false,"path":"categories/index.html","permalink":"http://www.shifeiqi.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-02T07:10:51.430Z","updated":"2019-03-02T07:10:51.430Z","comments":false,"path":"tags/index.html","permalink":"http://www.shifeiqi.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-03-02T06:59:01.674Z","updated":"2019-03-02T06:59:01.674Z","comments":true,"path":"2019/03/02/hello-world/","link":"","permalink":"http://www.shifeiqi.top/2019/03/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"快速排序","slug":"2021-01-31-快速排序","date":"2019-02-11T08:29:00.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2019/02/11/2021-01-31-快速排序/","link":"","permalink":"http://www.shifeiqi.top/2019/02/11/2021-01-31-快速排序/","excerpt":"","text":"🐶 原理 快速排序属于交换排序的一种，使用分治策略把一个序列分为两个子序列，思路如下： 基准&lt;pivot&gt;选取,从待排序序列中挑出一个元素，称之为”基准”(pivot)，一般选择队列中第一个元素或者最后一个元素。 分割&lt;partition&gt;操作, 所有比基准小的元素都被交换在基准前面，所有比基准大的元素都被交换到基准后面，分割结束之后，该基准就处于数列的中间位置。 递归地对小于基准值元素的子序列和大于基准值元素的子序列排序进行快速排序. 🐰 示例以下示例模拟对 [1, 6, 2, 8, 4, 3, 7, 9, 5] 进行快速排序过程, 基准选择待排序列的最后一个值. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556570x00 [1, 6, 2, 8, 4, 3, 7, 9, 5] ^pivot // 队列[1,6,2,8,4,3,7,9,5]选取基准5,进行第一次递归分割----------------------------------------------------------------------------------------0x01 [----比5小-----] [----比5大-----] [1, 3, 2, 4, &lt;5&gt;, 8, 7, 9, 6] // 第一次递归分割结束,获得两个子队列 // 队列[1,6,2,8,4,3,7,9,5]被基准5分割为[1,3,2,4]和[8,7,9,6]----------------------------------------------------------------------------------------0x10 [ ] [ ] [1, 3, 2, 4, &lt;5&gt;, 8, 7, 9, 6] ^pivot ^pivot // 对待分割子队列[1,3,2,4]选取基准4,进入第二次递归分割, // 对待分割子队列[8,7,9,6]选取基准6,进入第二次递归分割----------------------------------------------------------------------------------------0x11 [--比4小--] [] [] [--比6大---] [1, 3, 2, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, 9, 8] // 第二次递归分割结束,获得四个子队列 // [1,3,2,4]被4分割为 [1,3,2] 和 [] // [8,7,9,6]被6分割为 [] 和 [7,9,6]----------------------------------------------------------------------------------------0x20 [ ] [] [] [ ] [1, 3, 2, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, 9, 8] ^pivot ^pivot // 子队列[1,3,2]选取基准2,进入第三次递归分割 // 子队列[7,9,8]选取基准8,进入第三次递归分割 // []不做处理----------------------------------------------------------------------------------------0x21 [-] [-] [-] [-] [1, &lt;2&gt;, 3, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, &lt;8&gt;, 9] // 第三次递归分割结束,获取4个子队列 // [1,3,2]被3分割为[1]和[3] // [7,9,8]被8分割为[7]和[9]----------------------------------------------------------------------------------------0x30 [-] [-] [-] [-] [1, &lt;2&gt;, 3, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, 7, &lt;8&gt;, 9] ^pivot ^pivot ^pivot ^pivot // 子队列[1] [3] [7] [9] 都只包含一个基准元素,直接返回.----------------------------------------------------------------------------------------0x31 [&lt;1&gt;, &lt;2&gt;, &lt;3&gt;, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, &lt;7&gt;, &lt;8&gt;, &lt;9&gt;] // 获得排好队列 🐗 实现 Java 递归实现 12345678910111213141516171819202122232425262728293031323334353637383940// swap funcprivate void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// partition funcprivate int partition(int[] array, int left, int right) &#123; // 选取基准 int pivot = array[right]; int sIndex = right; // 分割 while(left &lt; right) &#123; while(array[left] &lt;= pivot &amp;&amp; left &lt; right) left ++; swap(array, left, sIndex); sIndex = left; // -- while(array[right] &gt;= pivot &amp;&amp; left &lt; right) right --; swap(array, sIndex, right); sIndex = right; &#125; return sIndex;&#125;// quick sort, recursively funcprivate void quickSort(int[] array, int left, int right) &#123; if(left &gt;= right) return; int parIndex = partition(array, left, right); // 递归 quickSort(array, left, parIndex - 1); quickSort(array, parIndex + 1, right);&#125;// sort interfacepublic int[] sort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); quickSort(array, 0, array.length - 1); return array;&#125; JavaScript 递归实现 123456789101112131415161718192021222324252627282930313233343536373839// swap funcconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// partition funcconst partition = (array, left, right) =&gt; &#123; // 选择基准 const pivot = array[right]; let sIndex = right; // 分割 while(left &lt; right) &#123; while(array[left] &lt;= pivot &amp;&amp; left &lt; right) left++; swap(array, left, sIndex); sIndex = left; // while(array[right] &gt;= pivot &amp;&amp; left &lt; right) right--; swap(array, sIndex, right); sIndex = right; &#125; return sIndex;&#125;// quick sort, recursively funcconst quickSort = (array, left, right) =&gt; &#123; if(left &gt;= right) return; const parIndex = partition(array, left, right); quickSort(array, left, parIndex - 1); quickSort(array, parIndex + 1, right);&#125;// sort interface funcconst sort = (nums) =&gt; &#123; const array = nums.slice(); quickSort(array, 0, array.length - 1); return array;&#125;","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]},{"title":"冒泡排序","slug":"2020-01-31-冒泡排序","date":"2019-02-11T07:58:00.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2019/02/11/2020-01-31-冒泡排序/","link":"","permalink":"http://www.shifeiqi.top/2019/02/11/2020-01-31-冒泡排序/","excerpt":"","text":"💣 原理 冒泡排序基本思想： 将待排序队列分为未排序子队列（位于左侧，初始值为待排序队列）和已排序子队列（位于右侧，初始值为空）。 走访未排序子队列，选择未排序子队列中的最大值交换到未排序子队列的列尾。 未排序子队列长度减一， 已排序子队列长度加一。 未排序子队列长度 == 0 ? 排序结束 ： 重复第2步。 时间复杂度：O(n^2)。 稳定。 🔫 示例 以下是对队列 [4, 2, 3, 6, 8, 1, 5] 进行冒泡排序的模拟过程（注：算法抽象过程描述，非程序运行过程）。1234567891011121314151617181920212223242526272829300 [4, 2, 3, 6, 8, 1, 5 ] [ 未排序子队列 ] [已排序子队列] // 将待排序队列分为 [未排序子队列] 和 [已排序子队列]------------------------------------------------------------------------------------1 [4, 2, 3, 6, 1, 5, 8] [ 未排序子队列 ] [已排序子队列] //第1次走访， //选取当前未排序子队列中最大值8冒泡到最后------------------------------------------------------------------------------------2 [4, 2, 3, 1, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第2次走访， //选取当前未排序子队列中最大值6冒泡到最后------------------------------------------------------------------------------------3 [4, 2, 3, 1, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第3次走访， //选取当前未排序子队列中最大值5冒泡到最后------------------------------------------------------------------------------------4 [ 2, 3, 1, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第4次走访， //选取当前未排序子队列中最大值4冒泡到最后------------------------------------------------------------------------------------5 [ 2, 1, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第5次走访， //选取当前未排序子队列中最大值3冒泡到最后------------------------------------------------------------------------------------ 6 [ 1, 2, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第6次走访， //选取当前未排序子队列中最大值2冒泡到最后------------------------------------------------------------------------------------ 7 [ 1, 2, 3, 4, 5, 6, 8] [ 未排序子队列 ] [已排序子队列] //第7次走访， //选取当前未排序子队列中最大值1冒泡到最后 🔪 算法实现 Java实现 123456789101112131415161718// swapprivate void swap(int[] array, int lIndex, int rIndex) &#123; int tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// sort interfacepublic int[] bubbleSort(int[] nums) &#123; int[] array = Arrays.copyOf(nums, nums.length); // bubble sort for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &gt; array[j + 1]) swap(array, j, j + 1); &#125; &#125; return array;&#125; JavaScript实现 1234567891011121314151617// swapconst swap = (array, lIndex, rIndex) =&gt; &#123; const tmp = array[lIndex]; array[lIndex] = array[rIndex]; array[rIndex] = tmp;&#125;// sort interfaceconst bubbleSort = nums =&gt; &#123; const array = nums.slice(); // bubble sort for(let i = 0; i &lt; array.length; i++) &#123; for(let j = 0; j &lt; array.length - i - 1; j++) if(array[j] &gt; array[j + 1]) swap(array, j, j + 1); &#125; return array;&#125;","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.shifeiqi.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.shifeiqi.top/tags/数据结构/"}]},{"title":"写在2019","slug":"2019-01-31-写在2019","date":"2019-01-31T08:21:00.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2019/01/31/2019-01-31-写在2019/","link":"","permalink":"http://www.shifeiqi.top/2019/01/31/2019-01-31-写在2019/","excerpt":"","text":"还有一个小时就要下班了，对着电脑大眼瞪小屏已经一下午，什么也没看下去，什么也没写出来。索性趁着这一个小时，写点2019年要干的事吧。想想2018年都已经过去了，好的坏的都来过，该想起该忘记的还是那个样子，索性就让这个本命年就这样过去吧，年终总结就不写了。随手写的随笔，格式就不那么严格了。 2019已经过去一个月了，还有11个月，时间还是挺漫长的，而我又是个急性子，计划一年的事情有点难为。倒不是说我做不到，而是想想一年要做的事情肯定有好多，容易让人焦虑。索性先列出前半年的计划，等到今年6月份再出下半年的计划，应该是没什么问题的。 1. 精神混蛋1.1 看书总之就看书吧，书单我没有想过，摸到哪本看哪本吧。看我那本还剩下三分之二的《百年孤独》；看那本卖了好久只翻过第一页的《流浪地球》；看那本心心念念但是一直没有买的《人类简史》；甚至于说看那一套念叨了好久的《冰与火之歌》。总之就是看书吧。 1.2 刷剧整个18年都没有好好地看过一整部，上半年打算把《冰与火之歌》或者《夺命毒师》或者《越狱》重新看一遍。这次要看全英文版的。 2. 技术入前端坑应该已经有大半年了，总觉得前端是一块刚刚开垦的地，需要新的拖拉机。2019年上半年的精力主要会集中在前端领域，更加深入地取了解学习前端。 2.1 函数式编程不仅仅是学习如何在JavaScript中使用这个模式，而是要深入学习这种思想，有必要的话可能会上 haskell 和《范畴论》。 2.2 编译原理重新温习编译原理吧，算是为深入了解前端底层打个基础啥的。《龙书》和红皮书要看完。 2.3 机器学习上半年应该会在机器学习方面入个门，毕竟这么火的技术不了解以下实在是可惜了。这个东西应该是会和我的老伙计一块学。 2.4写博客和做开源这个没啥好说的，show code &amp; pub blog 吧。 3. 身体身体真的很重要，2018年有一段时间晚上睡觉之前我都在想第二天还能不能醒过来。今年上半年的干的事就从最简单的跑步开始吧，嗯还要增重，太瘦了走路都没有安全感。按时吃饭，按时睡觉。 4. 其他上半年可能会出去走一趟，有可能是北京，有可能是长三角，也有可能是深圳。或者是海南和成都，甚至是西藏。目前还不确定，到时候再说吧。 就到这吧。 :)","categories":[{"name":"2019","slug":"2019","permalink":"http://www.shifeiqi.top/categories/2019/"}],"tags":[{"name":"日志","slug":"日志","permalink":"http://www.shifeiqi.top/tags/日志/"}]},{"title":"代理模式","slug":"2018-10-16-代理模式","date":"2018-10-16T07:36:00.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2018/10/16/2018-10-16-代理模式/","link":"","permalink":"http://www.shifeiqi.top/2018/10/16/2018-10-16-代理模式/","excerpt":"","text":"代理模式概述代理模式作为一种结构型设计模式，同时也是GoF所提的23中设计模式之一，在我们日常开发中大量被使用(远程代理、AOP等等)。本章将对代理模式的原理及设计思想进行介绍。 代理模式定义Provide a surrogate or placeholder for another object to control access to it.为其他对象提供一个代理对象用来控制对这个对象的访问。 代理模式简介开始介绍代理模式之前读者需要熟悉以下概念： 代理对象（Proxy）：用来代理真实对象，对真实对象的接口进行访问控制。 真实对象（RealSubject）：被代理对象，真正对外提供业务接口的对象。 代理模式的设计思路是在访问者和真实对象之间提供一个中间层（代理对象），用来对真实对象的业务接口进行包装。基于这个原理，代理对象在对真实对象的业务接口进行包装的时候可以提供额外的功能，比如：调用者的访问权限控制，日志记录等等。 proxy-pattern-01 代理模式分类按照代理对象的类模板的创建时机，代理模式可以分为静态代理和动态代理。 静态代理定义静态代理是指用于创建代理对象的类模板在编译期之前创建的，说的通俗一点，用于创建代理对象的类模板是由开发者手动编写的。（注：笔者以为静态代理叫做静态模板代理更容易理解一些） 通用设计本小节将介绍一个比较通用的静态代理实现方式。 类图 实现123456789101112131415161718192021222324252627282930313233343536373839404142/** * 业务接口 */interface Subject &#123; void doSomething();&#125;/** * 真实类模板 */class RealSubject implements Subject &#123; public void doSomething() &#123; System.out.println(\"real subject : do something!\"); &#125;&#125;/** * 代理类模板 */class Proxy implements Subject &#123; // 真实对象 private Subject subject; // 代理对象可通过ICO容器注入等配合使用 public Proxy(Subject subject) &#123; this.subject = subject; &#125; // 代理方法 public void doSomething() &#123; System.out.println(\"proxy subject : before do\"); subject.doSomething(); System.out.println(\"proxy subject : after do\"); &#125;&#125;/** * 模拟客户端 */public class Client &#123; public static void main(String[] args) &#123; // 创建代理对象 Subject proxy = new Proxy(new RealSubject()); // 调用代理方法 proxy.doSomething(); &#125;&#125; 动态代理定义动态代理是指用于创建代理对象的类模板是在程序运行期间动态生成的，使用动态代理可以避免静态代理存在的一些问题。 示例这里使用Java动态代理的官方教程来做演示。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 服务接口 */interface Subject &#123; Object doSomething(Object obj) throws Exception;&#125;/** * 真实类模板 */class RealSubject implements Subject &#123; @Override public Object doSomething(Object obj) throws Exception &#123; System.out.println(\"real subject : do something !\"); return new Object(); &#125;&#125;/** * 动态代理类，重写 &#123;@link java.lang.reflect.InvocationHandler#invoke(Object, Method, Object[])&#125; * 对真实对象的每一个服务接口进行包装 * * @see java.lang.reflect.InvocationHandler */class Proxy implements java.lang.reflect.InvocationHandler &#123; // real subject private Object subject; // constructor public Proxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"proxy subject : before\"); Object result = method.invoke(subject, args); System.out.println(\"proxy subject : after\"); return result; &#125; /** * 创建代理对象 */ public static Object newInstance(Object subject) &#123; return java.lang.reflect.Proxy.newProxyInstance( subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), new Proxy(subject) ); &#125;&#125;/** * 模拟客户端 */public class Client &#123; public static void main(String[] args) throws Exception&#123; Subject proxy = (Subject) Proxy.newInstance(new RealSubject()); proxy.doSomething(null); &#125;&#125; 参考资料 Proxy Design Pattern java-design-pattern 代理模式 设计模式之禅 Dynamic Proxy Classes","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.shifeiqi.top/tags/设计模式/"},{"name":"代理模式","slug":"代理模式","permalink":"http://www.shifeiqi.top/tags/代理模式/"},{"name":"Proxy","slug":"Proxy","permalink":"http://www.shifeiqi.top/tags/Proxy/"}]},{"title":"控制反转(IOC)","slug":"2018-08-26-控制反转(IOC)","date":"2018-08-26T06:28:00.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2018/08/26/2018-08-26-控制反转(IOC)/","link":"","permalink":"http://www.shifeiqi.top/2018/08/26/2018-08-26-控制反转(IOC)/","excerpt":"","text":"写在前面后端应用程序架构开发中，Spring是一个不得不迈过去的门槛。而对于学习和使用Spring，IOC又是一个不得不迈过去的门槛。 在此先简单解释一下什么是依赖： 依赖是什么？这里所解释的依赖是一个泛化的概念，即表示一个类依赖于另外一个类的定义。依赖对应Java类中的成员变量，局部变量，参数等等。对应的软件工程中的类图如下： dependency-example 其中一个比较常见的实现：12345class A &#123; // B称之为A的依赖 private B b;&#125;class B&#123;&#125; 无IOC架构现在假设我们要从头开始架构一个应用系统App，因为业务需要使用了底层框架组件A(三方jar或者底层框架模块)，那么一个比较常见的架构如下图所示： dependency-normal 由上图可以看出，App不仅依赖组件接口A，而且接口A的实现AImpl由应用程序创建。根据该架构图完成的编码如下:12345678910111213// A接口，为组件制定规范interface A &#123;&#125;// 具体实现类class AImpl implements A&#123;&#125;// 应用程序class App &#123; private A a; public App() &#123; a = new AImpl(); &#125;&#125; 现在考虑这么两种情况： 在开发过程中发现组件的实现AImpl不能满足现有的业务需求，需要将其换成A的另一个实现类AImplForNormal。 该系统需要在山东和山西地区同时上线，但是根据需求需要在山东使用组件A的实现类AImplForSD，在山西需要使用组件的实现类AImplForSX。 解决第一种情况的最笨办法就是将应用程序App中所有关于A的创建语句更改为A a = new AImplForNormal();，但是如果这样的语句有成千上万条，这必然不是一个好方法。解决第二种情况大约有这么两种笨方法: 在组件A的赋值语句中添加地区判断，或者为山东和山西地区写两套App系统代码，但这无疑都是馊主意。 其实上述两个问题归根结底只是一个问题：如何动态地创建App所依赖的 组件A的子类。即如何在应用程序运行期间选择性地去创建组件依赖对象，让被依赖对象能够像插件一样根据配置来进行插拔处理。 IOC架构现在我们根据引入IOC，来重新架构应用系统App。 ioc-normal 可以看出，应用程序仅仅依赖接口和IOC容器，而组件接口A的实现类由IOC容器根据配置有选择地创建。根据该架构完成的编码如下:12345678910111213141516171819202122232425// A接口，为组件制定规范interface A &#123;&#125;// 具体实现类class AImpl implements A&#123;&#125;class AImplForNormal implements A&#123;&#125;class AImplForSD implements A&#123;&#125;class AImplForSX implements A&#123;&#125;// IOC容器类static class IOCContainer &#123; public static A getA() throws Exception &#123; // 读取应用程序配置文件,假设读取到的配置信息是 com.cloudups.AImplForNormal String className = \"com.cloudups.AImplForNormal\"; return (A) Class.forName(className).newInstance(); &#125;&#125;// 应用程序class App &#123; private A a; public App() &#123; try&#123; a = IOCContainer.getA(); &#125;catch (Exception e) &#123; &#125; &#125;&#125; 由上述编码和架构图可以看出，组件接口A的实例对象可以由IOC容器在程序运行过程中根据配置文件有选择地进行创建，所以对于上文中的第一个问题，在开发过程中在配置文件中配置A的实现类AImplFornormal即可；而对于第二个问题，则在山东地区部署的时候修改配置文件中A的实现类为AImplForSD，在山西部署的时候修改配置文件中A的实现类为AImplForSX即可。 引入IOC容器之后的架构模式可以解决一个很棘手的问题：在程序运行期间根据配置有选择地创建组件的子对象。即将对象的创建权交给容器&lt;框架&gt;来完成，而不是由应用程序来创建对象。这就是所谓的控制反转&lt;IOC&gt;。` 参考资料 Inversion of Control Containers and the Dependency Injection pattern 控制反转和依赖注入-中文翻译","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"控制反转","slug":"控制反转","permalink":"http://www.shifeiqi.top/tags/控制反转/"},{"name":"IOC","slug":"IOC","permalink":"http://www.shifeiqi.top/tags/IOC/"}]},{"title":"Java-for-each-基础","slug":"2018-08-21-Java-for-each-基础","date":"2018-08-21T13:55:00.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2018/08/21/2018-08-21-Java-for-each-基础/","link":"","permalink":"http://www.shifeiqi.top/2018/08/21/2018-08-21-Java-for-each-基础/","excerpt":"","text":"写在前面for-each loop是JDK1.5增加的特性，其目的是为了更优雅简洁地迭代数组或者集合。for-each 的意思是指 for each item in container（没想到好的翻译）。 基本使用for-each 结构一般用来迭代 数组、容器、Iterable接口的子类，一般for-each结构如下：123for(Object item : items) &#123; // do something for item&#125; 迭代数组 1234String[] items = &#123;\"apple\", \"orange\", \"banana\"&#125;;for(String item : items) &#123; System.out.println(item);&#125; 迭代容器 1234List&lt;String&gt; items = Arrays.asList(\"apple\", \"orange\", \"banana\");for(String item : items) &#123; System.out.println(item);&#125; 迭代Iterable接口的子类JDK1.5 规定凡是实现了Iterable接口的类都可以用for-each进行迭代。 123456789101112131415161718192021222324252627282930313233343536373839static class IContainer implements Iterable&lt;String&gt; &#123; // 子元素集合 private List&lt;String&gt; items; // 构造方法 public IContainer() &#123; items = new ArrayList&lt;&gt;(); &#125; // 增加元素 public boolean add(String item) &#123; return items.add(item); &#125; // 重写Iterable接口方法 @Override public Iterator&lt;String&gt; iterator() &#123; return new Iterator&lt;String&gt;() &#123; private int index = 0; @Override public boolean hasNext() &#123; return index &lt; IContainer.this.items.size(); &#125; @Override public String next() &#123; return IContainer.this.items.get(index++); &#125; &#125;; &#125;&#125;// 测试代码 public static void main(String[] args) &#123; // 初始化容器 IContainer iContainer = new IContainer(); iContainer.add(\"apple\"); iContainer.add(\"orange\"); iContainer.add(\"banana\"); // for-each迭代容器 for(String item : iContainer) &#123; System.out.println(item); &#125; &#125; 注意：用for-each迭代容器和迭代Iterable子类是一个原理，因为容器类实现了接口Iterable。 原理for-each结构在编译期间会被编译器进行处理，最终被替换为真正的迭代结构，以下将以数组和容器说明for-each原理。 for-each迭代数组原理编译器会根据数组下标将for-each结构优化为真正的遍历结构，如下：开发人员的for-each代码： 123456789101112 String[] items = &#123;\"apple\", \"orange\", \"banana\"&#125;; for(String item : items) &#123; System.out.println(item); &#125;``` 经过编译器优化后的代码: ```java String[] items = &#123;\"apple\", \"orange\", \"banana\"&#125;; for(int i = 0 ; i &lt; items.length; i++) &#123; String item = items[i]; System.out.println(item); &#125; for-each 迭代容器原理编译器会使用容器的迭代器（Iterator）对容器迭代进行处理。如下：开发人员的for-each代码 1234List&lt;String&gt; items = Arrays.asList(\"apple\", \"orange\", \"banana\");for(String item : items) &#123; System.out.println(item);&#125; 经过编译器优化后的代码：12345List&lt;String&gt; items = Arrays.asList(\"apple\", \"orange\", \"banana\");for(Iterator&lt;String&gt; iterator = items.iterator(); iterator.hasNext(); ) &#123; String item = iterator.next(); System.out.println(item);&#125; Iterable接口详解JDK1.5规定，凡是实现了Iterable接口的子类均可以使用for-each结构来进行迭代，下图为Iterable接口类图： Iterable接口共三个方法，其中： iterator(): Iterator&lt;T&gt;: 获取迭代器。 forEach(Consumer&lt;? super T&gt;): void: 遍历容器（JDK1.8新增）。 spliterator(): Spliterator&lt;T&gt;: 获取可分裂迭代器(JDK1.8新增)。 优劣事物总有正反两面，for-each也不例外。 优势 代码更优雅简洁 减少手动遍历发生的逻辑错误。 劣处 不能更新容器中的元素，不能删除容器中的元素 只能串行操作，不能用于并行操作。 参考 The For-Each Loop Interface Iterable","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"for-each","slug":"for-each","permalink":"http://www.shifeiqi.top/tags/for-each/"},{"name":"基础","slug":"基础","permalink":"http://www.shifeiqi.top/tags/基础/"}]},{"title":"Java集合框架分析-Collection","slug":"2018-08-20-Java集合框架分析-Collection","date":"2018-08-20T13:55:00.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2018/08/20/2018-08-20-Java集合框架分析-Collection/","link":"","permalink":"http://www.shifeiqi.top/2018/08/20/2018-08-20-Java集合框架分析-Collection/","excerpt":"","text":"写在前面Collection 接口是collection 继承树的顶级接口，它定义了一系列的单元素容器操作的规范。这些规范大致可以分为四类：数据增加、数据删除、数据查找、其他。 URM例行往事，先上类图: 其中，Collection接口继承接口Iterable，表示Collection允许使用for-each结构进行迭代遍历。Collection接口所定义规范解释如下： 数据增加 数据删除 数据查找 其他","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"集合框架","slug":"集合框架","permalink":"http://www.shifeiqi.top/tags/集合框架/"},{"name":"源码分析","slug":"源码分析","permalink":"http://www.shifeiqi.top/tags/源码分析/"},{"name":"Collection","slug":"Collection","permalink":"http://www.shifeiqi.top/tags/Collection/"}]},{"title":"Java集合框架分析-Map","slug":"2018-08-19-Java集合框架分析-Map","date":"2018-08-19T13:55:00.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2018/08/19/2018-08-19-Java集合框架分析-Map/","link":"","permalink":"http://www.shifeiqi.top/2018/08/19/2018-08-19-Java集合框架分析-Map/","excerpt":"","text":"写在前面关于Java集合框架(Java Collections Framework)， 本应该早就动笔总结了，奈何已经被我充分重视但还是不够足够重视的Java集合框架牵涉的知识点太多，加之JDK 1.8引入的函数式导致笔者又一次深陷技术研究多日。 URM例行往事，先上类图。 java-design-pattern-iterator 以上类图根据JDK1.8源码绘制，该类图为具体实现&lt;HashMap、TreeMap等&gt;制定了一份通用规范。该规范主要有以下： 定义了键值对存储结构及操作规范(内部接口Entry)。 定义了键值对容器操作规范(Map)。 Entry接口分析Map作为键值对容器， 使用数据结构Entry来描述键值对。接口Map的内部接口Entry定义了通用键值对对外接口规范。如下： getKey() : K : 获取键。 getValue() : V : 获取值。 setValue(V) : V : 设置值，返回旧值。 comparingByKey() : Comparator&lt;Entry&lt;K, V&gt;&gt; : 获取比较器Comparator（依赖键比较）。 comparingByValue() : Comparator&lt;Entry&lt;K, V&gt;&gt; : 获取比较器Comparator(依赖值比较)。 comparingByKey(Comparator&lt;? super K&gt;) : Comparator&lt;Entry&lt;K, V&gt;&gt; : 获取比较器(使用自定义键比较器)。 comparingByValue(Comparator&lt;? super V&gt;) : Comparator&lt;Entry&lt;K, V&gt;&gt; : 获取比较器(使用自定义值比较器)。 Map接口分析Map既然作为集合容器，其提供的功能无外乎就是千年不变的数据操作功能：增加数据、删除数据、查找数据、更新数据。 Map定义的数据增加接口如下： put(K, V) : V : 将一队键值对放入容器，若存在key，则更新容器中的value putAll(Map&lt;? extends K, ? extends V&gt;) : void : 将键值对集合放入容器 putAbsent(K, V) : V : 若容器中不存在key，则将该键值对放入容器中 computeIfAbsent(K, Function&lt;? super K, ? extends V&gt;) : V : 若容器中不存在key，则将根据key计算出的value放入容器中。Function为函数接口，用来计算value。 computeIfPresent(K, BiFunction&lt;? super K, ? super V, ? extends V&gt;) : V : 若容器中存在key，则将根据key和oldValue计算出的value放入容器中。BiFunction为函数接口，用来计算value。 compute(K, BiFunction&lt;? super K, ? super V, ? extends V&gt;) : V : 不管容器中存不存在key，都将根据key和oldValue（或者null）计算出来的value放入容器。BiFunction为函数接口，用来计算value。 merge(K, V, BiFunction&lt;? super V, ? super V, ? extends V&gt;) : V : 将oldValue与value计算得到的newValue放入容器。BiFunction为函数接口,用来计算newValue。 Map定义的数据删除接口如下： remove(Object) : V : 删除指定key对应的键值对。 remove(Object, Object) : boolean : 删除指定key和value对应的键值对。 clear() : void : 清空容器。 Map定义的数据查询接口如下: get(Object) : V : 获取key对应的value。 getOrDefault(Object, V) : V : 获取key对应的value，若容器中不存在该键值对则返回默认值。 keySet() : Set&lt;K&gt; : 返回容器中所有的key。 values() : Collection&lt;V&gt; : 返回容器中所有的value。 entrySet() : Set&lt;Entry&lt;K, V&gt;&gt; : 返回容器中所有的键值对(Entry&lt;K,V&gt;)。 containsKey(Object) : boolean : 查询容器是否包含指定的key。 containsValue(Object) : boolean : 查询容器中是否包含指定的value。 Map定义的数据修改接口如下： replace(K, V) : V : 若容器中存在key，则替换key对应的value。 replace(K, V, V) : V : 替换容器中指定的key和value对应的value。 replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt;) : 遍历容器，使用函数接口BiFunction去替换键值对。 Map定义的其他接口: size() : int : 返回容器当前容量。 isEmpty() : boolean : 查询容器是否为空。 hashCode() : int : 返回容器哈希。 equals(Object) : boolean : 比对方法。 forEach(BiConsumer&lt;? super K, ? super V&gt;) : void : 遍历容器，使用回调函数BiConsumer处理每一对键值对。 参考资料 JDK源码","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"集合框架","slug":"集合框架","permalink":"http://www.shifeiqi.top/tags/集合框架/"},{"name":"源码分析","slug":"源码分析","permalink":"http://www.shifeiqi.top/tags/源码分析/"},{"name":"Map","slug":"Map","permalink":"http://www.shifeiqi.top/tags/Map/"}]},{"title":"设计模式-迭代器模式","slug":"2018-08-16-设计模式-迭代器模式","date":"2018-08-16T13:55:00.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2018/08/16/2018-08-16-设计模式-迭代器模式/","link":"","permalink":"http://www.shifeiqi.top/2018/08/16/2018-08-16-设计模式-迭代器模式/","excerpt":"","text":"写在前面小打小闹了一年，最近打算好好写点东西了。 定义Provide a way to access the elements of an aggregate object sequentially without exposing itsunderlying representation.提供一种顺序访问容器元素的方法，而又无需暴露容器的内部实现细节。 URM类图这里以Java源码中的迭代器为例。 实现1234567891011121314151617181920212223242526272829// 迭代器接口interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next();&#125;// 迭代器标志接口interface Iterable&lt;T&gt; &#123; Iterable&lt;T&gt; iterator();&#125;// 聚合容器类class AggregateObject implements Iterable&lt;String&gt; &#123; private List&lt;String&gt; items = new ArrayList&lt;&gt;(); // 迭代器内部类 class AggregateIterator implements Iterator&lt;String&gt; &#123; int index = 0; @Override public boolean hasNext() &#123; return index &lt; items.size(); &#125; @Override public String next() &#123; return items.get(index++); &#125; &#125; @Override public Iterable&lt;String&gt; iterator() &#123; return (Iterable&lt;String&gt;) this.new AggregateIterator(); &#125;&#125; 参考资料 设计模式之禅 java-design-patterns JDK 1.8 源码","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.shifeiqi.top/tags/设计模式/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://www.shifeiqi.top/tags/行为型模式/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"http://www.shifeiqi.top/tags/迭代器模式/"}]},{"title":"设计模式-模板方法模式","slug":"2018-08-09-设计模式-模板方法模式","date":"2018-08-09T06:43:10.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2018/08/09/2018-08-09-设计模式-模板方法模式/","link":"","permalink":"http://www.shifeiqi.top/2018/08/09/2018-08-09-设计模式-模板方法模式/","excerpt":"","text":"写在前面刚开始读jdk源码的时候感觉哇这代码好乱，为什么子类调父类，父类调子类，跳来跳去的眼睛都花了。。后来才知道，原来那种写法被叫做模板方法模式。 定义Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.TemplateMethod lets subclasses redefine certain steps of an algorithm without changing the algorithm’sstructure.定义一个操作中的算法的框架， 而将一些步骤延迟到子类中。 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 URM 类图模板方法模式 的通用类图如下所示： java-design-pattern-template 其中： AbstractClass 是抽象模板类，其中定义了模板方法，基本操作方法和钩子方法。 ConcreteClassA 具体模板方法，重写基本方法和钩子方法。 operateMethod() 基本操作方法，由子类重写，并且在模板方法中被调用。 templateMethod() 模板方法, 由抽象模板类实现，一般以固定的逻辑调用基本操作方法和钩子方法。 hookMethod() 钩子方法，一般是由抽象模板类提供的空方法，具体模板类可选择性的实现该方法。 具体思维导图如下所示： java-design-pattern-template 具体实现以下是模板方法模式的具体实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 抽象模板类abstract class AbstractClass &#123; // 基本操作方法 protected abstract void operateMethod1(); protected abstract void operateMethod2(); // 钩子方法 protected void hookMethod()&#123;&#125; // 模板方法 public void templateMethod() &#123; // 该模板方法的实现逻辑是依次调用基本操作方法和钩子方法 operateMethod1(); hookMethod(); operateMethod2(); &#125;&#125;// 具体模板类class ConcreteClassA extends AbstractClass &#123; @Override protected void operateMethod1() &#123; // 重写基本操作方法 System.out.println(\"ConcreteClassA.operateMethod1()\"); &#125; @Override protected void operateMethod2() &#123; // 重写基本操作方法 System.out.println(\"ConcreteClassA.operateMethod2()\"); &#125;&#125;// 具体模板类class ConcreteClassB extends AbstractClass &#123; @Override protected void operateMethod1() &#123; // 重写基本操作方法 System.out.println(\"ConcreteClassB.operateMethod1()\"); &#125; @Override protected void operateMethod2() &#123; // 重写基本操作方法 System.out.println(\"ConcreteClassB.operateMethod2()\"); &#125; @Override protected void hookMethod() &#123; // 重写钩子方法 super.hookMethod(); System.out.println(\"ConcreteClassB.hookMethod()\"); &#125;&#125;// 测试类public class App&#123; public static void main(String[] args) &#123; AbstractClass concreteA = new ConcreteClassA(); concreteA.templateMethod(); AbstractClass concreteB = new ConcreteClassB(); concreteB.templateMethod(); &#125;&#125; 参考 设计模式之禅 java-design-patterns","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.shifeiqi.top/tags/设计模式/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://www.shifeiqi.top/tags/行为型模式/"},{"name":"模板方法模式","slug":"模板方法模式","permalink":"http://www.shifeiqi.top/tags/模板方法模式/"}]},{"title":"Java四种引用方式","slug":"2018-08-08-Java四种引用方式","date":"2018-08-08T06:33:10.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2018/08/08/2018-08-08-Java四种引用方式/","link":"","permalink":"http://www.shifeiqi.top/2018/08/08/2018-08-08-Java四种引用方式/","excerpt":"","text":"基本概念自JDK1.2之后，Java对引用的概念进行了扩充，将引用类型分为四种:强引用，软引用，弱引用，虚引用。同时Java还新增了引用队列用来配合四种引用类型使用。 引用思维导图 其中： 强引用(Strong Reference)强引用是程序中普遍存在的，类似于Object obj = new Object();, 对于与强引用关联的对象，只要强引用还在，Java虚拟机永远都不会回收。 软引用(Soft Reference)软引用用来描述一些还有用但是并非必须的对象。对于软引用关联的对象，只有将要发生内存溢出时，Java虚拟机才会回收这些对象。 弱引用(Weak Reference)弱引用用来描述非必需对象。对于弱引用关联的对象，Java虚拟机只要进行垃圾回收，无论当前内存是否将要溢出，都会释放回收这些对象。 虚引用(Phantom Reference)虚引用只是用来标志一个对象，以便在对象被Java虚拟机回收释放之后能得到一个通知。虚引用对于对象的生命周期及其他状态并没有什么影响。 引用队列(Reference Queue)引用队列用来接收系统通知，当Java虚拟机将要回收对象时，虚拟机会将该对象的引用加入到引用队列中，用以通知该对象将要被垃圾回收。 使用示例 强引用一般Java代码中的引用关系即为强引用，如下: 1Object obj = new Object(); 软引用软引用 SoftReference 两种用法：单独使用以及与引用队列配合使用。 1234567891011 // 1. 单独使用软引用，若与软引用关联的对象被垃圾回收， // 则通过软引用get方法获取关联的对象为nullReference&lt;Object&gt; reference = new SoftReference&lt;Object&gt;(new Object());Object obj = reference.get(); // 2. 软引用与引用队列配合使用，若与软引用关联的对象被垃圾回收 // 则在对象被垃圾回收之前，软引用会被放入与之关联的引用队列ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();Reference&lt;Object&gt; reference = new SoftReference&lt;Object&gt;(new Object(), referenceQueue);// 获取引用队列中的第一个itemReference refFromQueue = referenceQueue.poll(); 虚引用虚引用也有两种用法：单独使用以及与引用队列配合使用。 12345678910111213 // 1. 单独使用弱引用，若与弱引用关联的对象被垃圾回收， // 则通过弱引用get方法获取关联的对象为nullReference&lt;Object&gt; reference = new SoftReference&lt;Object&gt;(new Object());System.gc(); // 垃圾回收Object obj = reference.get(); // null // 2. r弱引用与引用队列配合使用，若与弱引用关联的对象被垃圾回收 // 则在对象被垃圾回收之前，弱引用会被放入与之关联的引用队列ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();Reference&lt;Object&gt; reference = new SoftReference&lt;Object&gt;(new Object(), referenceQueue);System.gc(); // 垃圾回收Reference refFromQueue = referenceQueue.poll(); // 获取入队列的referenceObject obj = refFromQueue.get(); // null 虚引用虚引用只能和引用队列一同使用&lt;毕竟虚引用只是给对象打上一个标志，以便程序能够在对象被垃圾回收之后接收到通知&gt;，具体使用如下： 1234567 // 虚引用与引用队列配合使用，若与虚引用关联的对象被垃圾回收 // 则在对象被垃圾回收之前，虚引用会被放入与之关联的引用队列ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();Reference&lt;Object&gt; reference = new PhantomReference&lt;&gt;(new Object(), referenceQueue);System.gc(); // 垃圾回收Reference refFromQueue = referenceQueue.poll(); // 获取入队列的referenceObject obj = refFromQueue.get(); // null 源码略读说是源码略读，充其量只是介绍其API，等以后有空再补一章源码细读。 三种引用介绍Jdk1.2 虽然将引用扩充至四种引用类型，但是只提供三套引用类型相关类, 毕竟强引用至死不会被Java虚拟机回收，提供与之相关的Java类毫无意义。简单类图如下所示：其中：对于父类Reference，其中各方法的含义： get() 获取与引用关联的对象，若对象被垃圾回收，则返回null。各个子类根据需求重写了该方法。 clear() 清除与之关联的对象，该对象会在下次垃圾回收中被清除回收。 isEnqueued() 查询该引用是否进入引用队列，即与该引用关联的对象是否即将被垃圾回收或者已经被垃圾回收。 enqueue() 将该引用加入到引用队列中去。 引用队列引用队列用来存放即将被垃圾回收的对象的引用以及已经被垃圾回收的对象的引用。该队列内部是一个链表的实现，每次入队列都会在队列头插入节点，每次出队列都会从队列头取出节点，颇有栈的风格。其类图如下：其中，该类个方法介绍如下： poll() 从队列中弹出一个引用，若队列为空则立刻返回null。 remove() 删除队列头部节点并返回，若队列为空则一直等到该队列中有节点为止。 remove(long) 删除队列头部节点并返回,若队列为空则等待参数时间并返回。 参考 深入理解Java虚拟机 JDK 1.8 源码","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"引用方式","slug":"引用方式","permalink":"http://www.shifeiqi.top/tags/引用方式/"},{"name":"Reference","slug":"Reference","permalink":"http://www.shifeiqi.top/tags/Reference/"}]},{"title":"Java接口-基础","slug":"2018-08-02-Java接口-基础","date":"2018-08-02T01:47:10.000Z","updated":"2019-03-01T14:07:06.002Z","comments":true,"path":"2018/08/02/2018-08-02-Java接口-基础/","link":"","permalink":"http://www.shifeiqi.top/2018/08/02/2018-08-02-Java接口-基础/","excerpt":"","text":"写在前面接口是Java提供的一种非常强大的特性，使用接口机制可以实现封装隔离，将外部调用与内部实现分割开来。面向接口编程 是一种极其强大的编程思想，鉴于笔者水平与经验有限，此篇文章只阐述Java中接口相关的基础内容。本篇文章组织结构如下图： 接口定义 接口定义格式Java 中使用关键字 interface 来定义接口，定义格式如下： 1// [访问权限符] interface 接口名称&#123;&#125; 接口定义定义一个接口IPerson, 内容为空，如下: 1public interface IPerson &#123;&#125; 接口方法定义 接口方法定义注意 接口方法默认访问权限是 public ，且只能是 public。 接口方法只能是实例方法，不能用关键字 static 、final 修饰。（不然子类怎么重写接口方法？）。 接口方法是抽象方法，只能定义，不能实现（即不能有方法体）。 接口方法定义格式 1// [public] 返回值类型 方法名([参数类型 arg1, 参数类型 arg2 ...]); 接口方法定义示例定义一个接口 IPerson ，具备接口方法 say 和 run , 如下： 1234567public interface IPerson &#123; // 第一种形式，显示声明方法访问权限 public void say(); // 第二种形式，使用隐式的方法访问权限 public void run();&#125;public 接口属性定义 接口属性定义注意 接口属性只能被定义为 公有静态常量 , 即 public static final。 接口属性定义格式 1// [public] [static] [final] 属性类型 属性名称 = 初始值 ; 接口属性定义示例 123456public interface IPerson &#123; // 显示声明属性修饰符 public static final String race = \"human\"; // 使用隐式的属性修饰符 public static final String where = \"earth\";&#125; 接口继承 Java 可以通过继承来扩展接口，其一般的继承格式如下: 1// [访问权限符] interface 接口名称 [extends 父接口1 [, 父接口1, 父接口3 ...]] &#123;&#125; 一个示例 12public interface IPerson &#123;&#125;interface IYPerson extends IPerson, Serializable &#123;&#125; 参考资料 Java编程思想","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"接口","slug":"接口","permalink":"http://www.shifeiqi.top/tags/接口/"},{"name":"Interface","slug":"Interface","permalink":"http://www.shifeiqi.top/tags/Interface/"}]},{"title":"设计模式-单例模式","slug":"2018-08-01-设计模式-单例模式","date":"2018-08-01T06:54:10.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2018/08/01/2018-08-01-设计模式-单例模式/","link":"","permalink":"http://www.shifeiqi.top/2018/08/01/2018-08-01-设计模式-单例模式/","excerpt":"","text":"定义Ensure a class has only one instance, and provide a global point of access to it.确保一个类只有一个实例，并且向整个应用提供这个实例。 URM单例类模板一般的定义格式如下: 拥有一个静态属性用来指向单例对象。 构造方法私有化，避免其他对象创建该类实例&lt;不然叫啥单例&gt;。 提供一个公有接口提供单例对象。 具体类图如下: 实现根据单例对象被创建的时机，单例模式的实现一般被分为以下几种： 单例模式-URM 各种写法如下所示： 饿汉写法 (eagerly initialized singleton)饿汉写法利用Java的类加载机制，在类加载的时候对实例进行初始化，巧妙地避开了多线程竞争导致实例初始化多次的问题。 12345678910111213public class Singleton &#123; private static final Singleton INSTANCE = new Singleton(); // 私有化构造函数，避免该类被其他对象初始化 private Singleton() &#123; &#125; // 共有接口，获取单例对象 public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 懒汉写法-线程安全 (lazily initialized singleton)懒汉写法基于懒加载(lazy loading)原理，在第一次使用的时候该实例的时候才会对该实例进行实例化操作。在多线程模式下，由于多线程竞争锁会导致效率问题。 12345678910111213141516public class Singleton &#123; private static Singleton INSTANCE; // 私有化构造函数，避免该类被其他对象初始化 private Singleton() &#123; &#125; // 共有接口，获取单例对象 public static synchronized Singleton getInstance() &#123; if(INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; return INSTANCE; &#125;&#125; 懒汉写法-双检锁DCL (Double Check Locking)DCL基于线程安全的懒汉模式，在一定程度上解决了多线程竞争锁导致的效率问题。 1234567891011121314151617181920public class Singleton &#123; private static Singleton INSTANCE; // 私有化构造函数，避免该类被其他对象初始化 private Singleton() &#123; &#125; // 共有接口，获取单例对象 public static Singleton getInstance() &#123; if(INSTANCE == null) &#123; synchronized (Singleton.class) &#123; if(INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 懒汉写法-内部类基于内部类的懒汉模式基于以下原理:内部类第一次被使用的时候才会被Java虚拟机加载，进而去实例化内部类的类属性。 123456789101112131415 public class Singleton &#123; // 私有化构造函数，避免该类被其他对象初始化 private Singleton() &#123; &#125; // 共有接口，获取单例对象 public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; // 内部类，持有单例对象 private static class SingletonHolder &#123; public static final Singleton INSTANCE = new Singleton(); &#125;&#125; 参考资料 设计模式之禅 java-design-patterns Double-Checked Locking","categories":[{"name":"2018","slug":"2018","permalink":"http://www.shifeiqi.top/categories/2018/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.shifeiqi.top/tags/设计模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://www.shifeiqi.top/tags/创建型模式/"},{"name":"单例模式","slug":"单例模式","permalink":"http://www.shifeiqi.top/tags/单例模式/"}]},{"title":"Redis and Jedis（Lists-Java）","slug":"2017-09-29-Redis and Jedis（Lists-Java）","date":"2017-10-01T01:28:25.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2017/10/01/2017-09-29-Redis and Jedis（Lists-Java）/","link":"","permalink":"http://www.shifeiqi.top/2017/10/01/2017-09-29-Redis and Jedis（Lists-Java）/","excerpt":"","text":"API介绍及示例Jedis中关于List操作的API如下： Jedis.blpop(int timeout,String... keys)：从左边获取并删除列表中的第一个元素，timeout表示阻塞时间。 123456789101112// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 弹出名为tList的列表中的第一个元素，阻塞时间为10sList&lt;String&gt; ret1 = jedis.blpop(10, \"tList\");/* * 按照顺序在l1、l2、l3三个列表中寻找一个元素并弹出。 * redis首先弹出l1中的第一个元素并结束，如果l1为空，则弹出l2中的第一个元素并结束，如果l2为空， * 则弹出l3中的第一个元素并结束；如果l3为空，则进入10s阻塞时间。 */List&lt;String&gt; ret2 = jedis.blpop(10, \"l1\", \"l2\", \"l3\"); Jedis.brpop(int timeout,String... keys);: 从右边获取并删除列表的第一个元素，timeout表示阻塞时间。 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 从右边获取并删除列表list的第一个元素，阻塞时间为10sList&lt;String&gt; ret1 = jedis.brpop(10, \"list\"); Jedis.brpoplpush(String source,String destination,int timeout)：弹出并删除source中的第一个元素，将其推入到destination中，阻塞时间为timeout。 123456// 创建Redis客户端实例 Jedis jedis = new Jedis(\"10.1.10.53\", 6379); // 授权 jedis.auth(\"redis\"); // 弹出l1中的第一个元素，并将其推入到l2中，阻塞时间为5s String ret = jedis.brpoplpush(\"l1\", \"l2\", 5); Jedis.lindex(key, index): 获取列表中索引为index的元素 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 获取l1中索引为2的元素String ret = jedis.lindex(\"l1\", 2); Jedis.linsert(String key,LIST_POSITION where,String pivot,String value):在列表的元素pivot之前或者之后插入value 12345678// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 在列表l1中元素\"hello\"之前插入\"word\"Long ret = jedis.linsert(\"l1\", LIST_POSITION.BEFORE, \"hello\", \"word\");// 在列表l1中的元素\"hello\"之后插入\"word\"Long ret2 = jedis.linsert(\"l1\", LIST_POSITION.AFTER, \"hello\", \"word\"); Jedis.llen(String key);：获取列表长度 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 获取列表l1的长度Long ret = jedis.llen(\"l1\"); Jedis.lpop(String key): 从队列的左边出队一个元素。 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 从队列l1的左边弹出一个元素String ret = jedis.lpop(\"l1\"); Jedis.lpush(String key,String... strings): 从队列的左边入队一个或多个元素。 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 从队列l1的左边入元素\"hello\"long ret = jedis.lpush(\"l1\", \"hello\"); Jedis.lpushx(String key,String... string);: 当队列存在时，从队列的左边入队一个元素（自然当队列不存在时redis不做操作了）。 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");//当l1存在时，将\"hello\"从l1的左边入队。long ret = jedis.lpushx(\"l1\", \"hello\"); Jedis.lrange(String key,long start,long end);: 获取队列中指定范围的元素,从左向右。 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 获取l1中index从2到4的元素List&lt;String&gt; ret = jedis.lrange(\"l1\", 2, 4); Jedis.lrem(String key,long count,long value): 移除列表中的value（count参数的使用见下）。 12345678910// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 从左往右删除2个l1中的值为\"hello\"的元素Long ret = jedis.lrem(\"l1\", 2, \"hello\");// 从右往左删除3个l1中值为\"word\"的元素long ret2 = jedis.lrem(\"l1\", -3, \"hello\");// 删除l1中所有的值为haha的元素long ret3 = jedis.lrem(\"l1\", 0, \"haha\"); Jedis.lset(String key,long index,String value): 设置列表中下标为index(从左到右)的值, 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 设置l1中下标为2的元素的值为helloString ret = jedis.lset(\"l1\", 2, \"hello\"); Jedis.ltrim(String key,long start,long end): 清理列表，只保留从start到stop下标的元素。 12345678// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 清理列表l1，保留指定范围元素(2-9)。String ret = jedis.ltrim(\"l1\", 2, 9);// 清理列表l2，保留指定范围元素(1-l2中倒数第二个元素的下标)。String ret2 = jedis.ltrim(\"l1\", 1, -2); Jedis.rpop(String key): 从队列的右边出队一个元素并删除。 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 从队列l1的右边弹出一个元素并删除String value = jedis.rpop(\"l1\"); Jedis.rpoplpush(String srckey,String dstkey): 从source的右边出队一个元素，并将其从左边入队到destination中。 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 从l1的右边出队一个元素，并将其从左边入队到l2中去String ret = jedis.rpoplpush(\"l1\", \"l2\"); Jedis.rpush(String key,String... strings): 将元素从队列的右边入队。 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 将元素hello从队列l1的右边入队long ret = jedis.rpush(\"l1\", \"hello\"); Jedis.rpushx(String key,String... string): 如果队列存在时，从该队列的右边入队元素 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 如果队列l1存在，则从l1的右边入队元素hellolong ret = jedis.rpushx(\"l1\", \"hello\"); 参考资料Jedis官方文档","categories":[{"name":"2017","slug":"2017","permalink":"http://www.shifeiqi.top/categories/2017/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"Redis","slug":"Redis","permalink":"http://www.shifeiqi.top/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"http://www.shifeiqi.top/tags/Jedis/"},{"name":"NoSql","slug":"NoSql","permalink":"http://www.shifeiqi.top/tags/NoSql/"},{"name":"内存数据库","slug":"内存数据库","permalink":"http://www.shifeiqi.top/tags/内存数据库/"},{"name":"Key-Value","slug":"Key-Value","permalink":"http://www.shifeiqi.top/tags/Key-Value/"}]},{"title":"Redis and Jedis（Lists-Command）","slug":"2017-09-29-Redis and Jedis（Lists-Command）","date":"2017-10-01T01:28:25.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2017/10/01/2017-09-29-Redis and Jedis（Lists-Command）/","link":"","permalink":"http://www.shifeiqi.top/2017/10/01/2017-09-29-Redis and Jedis（Lists-Command）/","excerpt":"","text":"Command介绍Redis中关于List的命令如下： BLPOP key [key...] timeout： 获取并删除列表中的第一个元素，timeout表示阻塞时间。 123456#弹出名为tList的列表中的第一个元素，阻塞时间为10sBLPOP tList 10#按照顺序在l1、l2、l3三个列表中寻找一个元素并弹出。#redis首先弹出l1中的第一个元素并结束，如果l1为空，则弹出l2中的第一个元素并结束，如果l2为空，#则弹出l3中的第一个元素并结束；如果l3为空，则进入10s阻塞时间。BLPOP l1 l2 l3 10 BRPOP key [key...] timeout: 获取并删除列表的最后一个元素，timeout表示阻塞时间。 12#弹出名为list的列表中的最后一个元素，阻塞时间为10sBRPOP list 10 BRPOPLPUSH source destination timeout：弹出并删除source中的第一个元素，将其推入到destination中，阻塞时间为timeout。 12#弹出l1中的第一个元素，并将其推入到l2中，阻塞时间为5sBRPOPLPUSH l1 l2 5 LINDEX key index: 获取列表中索引为index的元素 12#获取l1中索引为2的元素LINDEX l1 2 LINSERT key BEFORE|AFTER pivot value:在列表的元素pivot之前或者之后插入value 1234#在列表l1中元素\"hello\"之前插入\"word\"LINSERT l1 BEFORE \"hello\" \"word\"#在列表l1中的元素\"hello\"之后插入\"word\"LINSERT l1 AFTER \"hello\" \"word\" LLEN：获取列表长度 12#获取列表l1的长度LLEN l1 LPOP key: 从队列的左边出队一个元素。 12#从队列l1的左边弹出一个元素LPOP l1 LPUSH key value [value ...]: 从队列的左边入队一个或多个元素。 12#从队列l1的左边入元素\"hello\"LPUSH l1 hello LPUSHX key value: 当队列存在时，从队列的左边入队一个元素（自然当队列不存在时redis不做操作了）。 12#当l1存在时，将\"hello\"从l1的左边入队。LPUSHX l1 hello LRANGE key statrt stop: 获取队列中指定范围的元素。 12#获取l1中index从2到4的元素LRANGE l1 2 4 LREM key count value: 移除列表中的value（count参数的使用见下）。 123456#从左往右删除2个l1中的值为\"hello\"的元素LREM l1 2 hello#从右往左删除3个l1中值为\"word\"的元素LREM l1 -3 word#删除l1中所有的值为haha的元素LREM l1 0 haha LSET key index value: 设置列表中下标为index的值 12#设置l1中下标为2的元素的值为helloLSET l1 2 hello LTRIM key start stop: 清理列表，只保留从start到stop下标的元素。 1234#清理列表l1，保留指定范围元素(2-9)。LTRIM l1 2 9#清理列表l2，保留指定范围元素(1-l2中倒数第二个元素的下标)。LTRIM l2 1 -2 RPOP key: 从队列的右边出队一个元素并删除。 12#从队列l1的右边弹出一个元素并删除RPOP l1 RPOPLPUSH source destination: 从source的右边出队一个元素，并将其从左边入队到destination中。 12#从l1的右边出队一个元素，并将其从左边入队到l2中去RPOPLPUSH l1 l2 RPUSH key value [value...]: 将元素从队列的右边入队。 12#将元素hello从队列l1的右边入队RPUSH l1 hello RPUSHX key value: 如果队列存在时，从该队列的右边入队元素 12#如果队列l1存在，则从l1的右边入队元素helloRPUSHX l1 hello 参考资料Redis官方资料","categories":[{"name":"2017","slug":"2017","permalink":"http://www.shifeiqi.top/categories/2017/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.shifeiqi.top/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"http://www.shifeiqi.top/tags/Jedis/"},{"name":"NoSql","slug":"NoSql","permalink":"http://www.shifeiqi.top/tags/NoSql/"},{"name":"内存数据库","slug":"内存数据库","permalink":"http://www.shifeiqi.top/tags/内存数据库/"},{"name":"Key-Value","slug":"Key-Value","permalink":"http://www.shifeiqi.top/tags/Key-Value/"},{"name":"Command","slug":"Command","permalink":"http://www.shifeiqi.top/tags/Command/"}]},{"title":"Redis and Jedis（key生存时间管理-Java）","slug":"2017-09-29-Redis and Jedis（key生存时间管理-Java）","date":"2017-09-30T08:47:15.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2017/09/30/2017-09-29-Redis and Jedis（key生存时间管理-Java）/","link":"","permalink":"http://www.shifeiqi.top/2017/09/30/2017-09-29-Redis and Jedis（key生存时间管理-Java）/","excerpt":"","text":"API介绍与Redis客户端Command向对应，Jedis关于key生存时间管理的API有下面几个： Jedis.expire(key, seconds)：设置key的过期时间，以秒为单位。 Jedis.pexpire(key, milliseconds)：设置key的过期时间，以毫秒为单位。 Jedis.expireAt(key, unixTime)：设置key的过期时间，时间参数为Unix时间戳（从1970年1月1日开始经过的秒数）。 Jedis.pexpireAt(key, millisecondsTimestamp):设置key的过期时间，时间参数为Unix时间戳，以毫秒计。 Jedis.ttl(key): 返回key的剩余过期时间。 Jedis.pttl(key): 返回key的剩余过期时间，以毫秒计。 Jedis.persist(key)：移除key的过期时间。 API使用 设置appleKey的过期时间为60s。 12345678// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 设置appleKey的过期时间为60s，以秒的方式jedis.expire(\"appleKey\", 60);// 设置appleKey的过期时间为60s,以毫秒的方式jedis.pexpire(\"appleKey\", 60000); 返回appleKey的剩余时间 12345678// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 返回appleKey的剩余时间，以秒的方式long time = jedis.ttl(\"appleKey\");// 返回appleKey的剩余时间，以毫秒的方式long milliTime = jedis.pttl(\"appleKey\"); 移除appleKey的过期时间（使appleKey永久存在） 123456// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 移除appleKey的过期时间jedis.persist(\"appleKey\"); 参考资料Jedis官方文档","categories":[{"name":"2017","slug":"2017","permalink":"http://www.shifeiqi.top/categories/2017/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"Redis","slug":"Redis","permalink":"http://www.shifeiqi.top/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"http://www.shifeiqi.top/tags/Jedis/"},{"name":"NoSql","slug":"NoSql","permalink":"http://www.shifeiqi.top/tags/NoSql/"},{"name":"内存数据库","slug":"内存数据库","permalink":"http://www.shifeiqi.top/tags/内存数据库/"},{"name":"Key-Value","slug":"Key-Value","permalink":"http://www.shifeiqi.top/tags/Key-Value/"}]},{"title":"Redis and Jedis（key生存时间管理-Command）","slug":"2017-09-29-Redis and Jedis（key生存时间管理-Command）","date":"2017-09-30T06:29:12.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2017/09/30/2017-09-29-Redis and Jedis（key生存时间管理-Command）/","link":"","permalink":"http://www.shifeiqi.top/2017/09/30/2017-09-29-Redis and Jedis（key生存时间管理-Command）/","excerpt":"","text":"Command 介绍在Redis中的key是具备生存时间的，一般一个key的默认生存时间是永久存在的（你要是不开心删掉它那就另说了。。。）。当然你也可以对key的生存时间进行设置。与key的生存时间相关的Command有如下几个： EXPIRE key seconds：设置key的过期时间，以秒为单位。 PEXPIRE key milliseconds：设置key的过期时间，以毫秒为单位。 EXPIREAT key timestamp：设置key的过期时间，时间参数为Unix时间戳（从1970年1月1日开始经过的秒数）。 PEXPIREAT key millisecondes-timestamp:设置key的过期时间，时间参数为Unix时间戳，以毫秒计。 TTL key: 返回key的剩余过期时间。 PTTL key: 返回key的剩余过期时间，以毫秒计。 PERSIST key：移除key的过期时间。 Command使用 设置appleKey的过期时间为60s。 12EXPIRE appleKey 60 #以秒的方式PEXPIRE appleKey 60000 #以毫秒的方式 返回appleKey的剩余过期时间 12TTL appleKey #以秒的方式PTTL appleKey #以毫秒的方式 移除appleKey的过期时间（使appleKey永久存在） 1PERSIST appleKey #移除appleKey的过期时间 参考资料Redis官方资料","categories":[{"name":"2017","slug":"2017","permalink":"http://www.shifeiqi.top/categories/2017/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.shifeiqi.top/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"http://www.shifeiqi.top/tags/Jedis/"},{"name":"NoSql","slug":"NoSql","permalink":"http://www.shifeiqi.top/tags/NoSql/"},{"name":"内存数据库","slug":"内存数据库","permalink":"http://www.shifeiqi.top/tags/内存数据库/"},{"name":"Key-Value","slug":"Key-Value","permalink":"http://www.shifeiqi.top/tags/Key-Value/"},{"name":"Command","slug":"Command","permalink":"http://www.shifeiqi.top/tags/Command/"}]},{"title":"Redis and Jedis（事务管理-Java）","slug":"2017-09-29-Redis and Jedis（事务管理-Java）","date":"2017-09-29T10:20:32.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2017/09/29/2017-09-29-Redis and Jedis（事务管理-Java）/","link":"","permalink":"http://www.shifeiqi.top/2017/09/29/2017-09-29-Redis and Jedis（事务管理-Java）/","excerpt":"","text":"API 介绍Jedis中与Redis事务相关一共有两个类:Jedis和Transaction，相关API如下： Jedis.multi()：标志着事务的开始，从Jedis.multi开始到Transaction.exec()（或者Transaction.discard()）之间的代码会被Redis服务器作为原子操作执行。返回值为OK。 Transaction.exec()：事务提交执行，和Jedis.multi()成对出现。 Transaction.discard()：事务回滚，和Jedis.multi()成对出现。返回值为OK。 Jedis.watch(String...keys)：监视一个（多个）key，从Jedis.watch(String...keys)执行结束到MULTI命令执行开始的时间段中，如果这些key被其他客户端改动，事务将被打断以致执行失败。 Jedis.unwatch()：取消Jedis.watch(String...keys)所标志的所有的key的监视。 API使用 事务提交 12345678910// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 开启事务Transaction transaction = jedis.multi();// 操作Redistransaction.set(\"appleKey\", \"appleValue\");// 提交事务transaction.exec(); 事务回滚 12345678910// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 开启事务Transaction transaction = jedis.multi();// 操作Redistransaction.set(\"appleKey\", \"appleValue\");// 回滚事务transaction.discard(); 监视keys 12345678910111213// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 监听keys，从jedis.watch()开始到transaction.multi()执行的这段时间，// 如果有其他客户端对appleKey进行操作，则该事务会被打断jedis.watch(\"appleKey\");// 开启事务Transaction transaction = jedis.multi();// 操作Redistransaction.set(\"appleKey\", \"appleValue\");// 回滚事务transaction.exec(); 取消keys监视 123456789101112131415// 创建Redis客户端实例Jedis jedis = new Jedis(\"10.1.10.53\", 6379);// 授权jedis.auth(\"redis\");// 监听keysjedis.watch(\"appleKey\",\"androidKey\");// 取消监视keys,从当前时间开始到 jedis.multi() 被执行的时间段中，// 其他客户端对appleKey或者androidKey的操作将不会影响该事务的执行。jedis.unwatch();// 开启事务Transaction transaction = jedis.multi();// 操作Redistransaction.set(\"appleKey\", \"appleValue\");// 回滚事务transaction.exec(); 参考文献Jedis官方文档","categories":[{"name":"2017","slug":"2017","permalink":"http://www.shifeiqi.top/categories/2017/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"Redis","slug":"Redis","permalink":"http://www.shifeiqi.top/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"http://www.shifeiqi.top/tags/Jedis/"},{"name":"NoSql","slug":"NoSql","permalink":"http://www.shifeiqi.top/tags/NoSql/"},{"name":"内存数据库","slug":"内存数据库","permalink":"http://www.shifeiqi.top/tags/内存数据库/"},{"name":"Key-Value","slug":"Key-Value","permalink":"http://www.shifeiqi.top/tags/Key-Value/"}]},{"title":"Redis and Jedis（事务管理-Command）","slug":"2017-09-29-Redis and Jedis（事务管理-Command）","date":"2017-09-29T08:27:30.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2017/09/29/2017-09-29-Redis and Jedis（事务管理-Command）/","link":"","permalink":"http://www.shifeiqi.top/2017/09/29/2017-09-29-Redis and Jedis（事务管理-Command）/","excerpt":"","text":"Command介绍从官方文档中可以看到，Redis关于事务管理方面的命令一共5个，各个命令及所代表的含义如下： MULTI：标志着事务的开始，从MULTI开始到EXEC（或者DISCARD）之间的命令会被Redis服务器作为原子操作执行。返回值为OK。 EXEC: 事务提交执行，和MULTI成对出现。 DISCARD: 事务回滚，和MULTI成对出现。返回值为OK。 WATCH key[key...]:监视一个（多个）key，从WATCH命令执行结束到MULTI命令执行开始的时间段中，如果这些key被其他客户端改动，事务将被打断以致执行失败。 UNWATCH: 取消WATCH所标志的所有的key的监视。 Command操作 事务提交 123MULTI #开启事务SET KEY \"VALUE\"#操作RedisEXEC #提交事务 事务回滚 123MULTI #开启事务SET KEY \"VALUE\"#操作RedisDISCARD #回滚事务 监视keys 123456WATCH appleKey #监视一个名为appleKey的key#从当前时间开始到 MULTI 命令被执行的时间里如果有其他的客户端对appleKey进行修改，则下面的事务将会被打断#MULTI #开启事务SET appleKey \"VALUE\"#操作RedisEXEC #提交事务，如果事务被打断将返回 nil 取消keys监视 1234567WATCH appleKey androidKey #监视一个名为appleKey的keyUNWATCH #取消对appleKey和androidKey的监视#从当前时间开始到 MULTI 命令被执行的时间段中，其他客户端对appleKey或者androidKey的操作将不会影响事务的执行#MULTI #开启事务SET appleKey \"VALUE\"#操作RedisEXEC #提交事务 参考文献Redis官方文档","categories":[{"name":"2017","slug":"2017","permalink":"http://www.shifeiqi.top/categories/2017/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.shifeiqi.top/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"http://www.shifeiqi.top/tags/Jedis/"},{"name":"NoSql","slug":"NoSql","permalink":"http://www.shifeiqi.top/tags/NoSql/"},{"name":"内存数据库","slug":"内存数据库","permalink":"http://www.shifeiqi.top/tags/内存数据库/"},{"name":"Key-Value","slug":"Key-Value","permalink":"http://www.shifeiqi.top/tags/Key-Value/"},{"name":"Command","slug":"Command","permalink":"http://www.shifeiqi.top/tags/Command/"}]},{"title":"记英剧《黑镜》","slug":"2017-09-10-记英剧《黑镜》","date":"2017-09-10T12:14:00.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2017/09/10/2017-09-10-记英剧《黑镜》/","link":"","permalink":"http://www.shifeiqi.top/2017/09/10/2017-09-10-记英剧《黑镜》/","excerpt":"","text":"按照一贯的思维，看完一部电视剧或者是一本书，应当写一点观后感读后感之类的，但是我并不想写。我只是想说，今天我看完了《黑镜》的第一季，给我的感觉符合我的预期。算了，放一张盗来的海报记录一下吧。 黑镜 第一季","categories":[{"name":"2017","slug":"2017","permalink":"http://www.shifeiqi.top/categories/2017/"}],"tags":[{"name":"英剧","slug":"英剧","permalink":"http://www.shifeiqi.top/tags/英剧/"},{"name":"黑镜","slug":"黑镜","permalink":"http://www.shifeiqi.top/tags/黑镜/"},{"name":"日记","slug":"日记","permalink":"http://www.shifeiqi.top/tags/日记/"}]},{"title":"JAVA对象序列化之BYTE流","slug":"2017-08-29-JAVA对象序列化之BYTE流","date":"2017-08-27T05:25:00.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2017/08/27/2017-08-29-JAVA对象序列化之BYTE流/","link":"","permalink":"http://www.shifeiqi.top/2017/08/27/2017-08-29-JAVA对象序列化之BYTE流/","excerpt":"","text":"写在前面最近项目上有一个需求需要大量的将Java对象进行序列化并且进行还原，本文将介绍如何将Java对象序列化为Byte。 构造可序列化对象一个Java对象可序列化的前提是这个对象可序列化（😰。。。），具体来讲就是给这个Java对象打上可序列化的标志。一般的做法是实现接口 Serializable ,如下面的代码，定义一个可序列化的 Apple 类。1234567891011121314151617181920public class Apple implements Serializable&#123; private static final long serialVersionUID = 1L; private String name; private Color color; private double weight; public Apple(String name, Color color, double weight) &#123; super(); this.name = name; this.color = color; this.weight = weight; &#125; @Override public String toString() &#123; return \"Apple [name=\" + name + \", color=\" + color + \", weight=\" + weight + \"]\"; &#125;&#125; 其中： Serializable 接口是一个空接口，不需要实现任何的方法。其定义如下: 12public interface Serializable &#123;&#125; 静态常量 serialVersionUID 用来验证版本的一致性。当对 Byte 流进行反序列化时，Java虚拟机会比对Byte流中的 serialVersionUID 是否和本地相应的实体类中的 serialVersionUID，如果不一致则会抛出异常。 可序列化Java对象的成员也必须是可序列化的。 序列化Java对象将Java对象进行序列化的代码如下所示：12345678910private static byte[] object2Byte(Object object) throws IOException &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(object); byte[] bytes = bos.toByteArray(); oos.close(); bos.close(); return bytes;&#125; 其中： ByteArrayOutputStream 用于将数据转化为字节数组。 ObjectOutputStream 用于将Java对象写入输出流。 反序列化Java对象将字节流反序列的代码如下：12345678910private static Object byte2Object(byte[] bytes) throws ClassNotFoundException, IOException &#123; ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis); Object object = ois.readObject(); ois.close(); bis.close(); return object;&#125; 其中： ByteArrayInputStream 用于将字节数组读入输入流。 ObjectInputStream 用于将Java对象从输入流中读出。","categories":[{"name":"2017","slug":"2017","permalink":"http://www.shifeiqi.top/categories/2017/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"对象","slug":"对象","permalink":"http://www.shifeiqi.top/tags/对象/"},{"name":"序列化","slug":"序列化","permalink":"http://www.shifeiqi.top/tags/序列化/"},{"name":"BYTE","slug":"BYTE","permalink":"http://www.shifeiqi.top/tags/BYTE/"}]},{"title":"CORS 浏览器跨域请求","slug":"2017-08-26-CORS 浏览器跨域请求","date":"2017-08-26T06:34:10.000Z","updated":"2019-03-01T14:07:05.986Z","comments":true,"path":"2017/08/26/2017-08-26-CORS 浏览器跨域请求/","link":"","permalink":"http://www.shifeiqi.top/2017/08/26/2017-08-26-CORS 浏览器跨域请求/","excerpt":"","text":"写在前面本文不对CORS原理做解释，只通过一个小小的demo来介绍如何使用CORS来进行跨域请求。 浏览器目前市面上的浏览器都支持CORS，因此，只需使用js代码正常发送网络请求即可。例如，我想请求 10.1.10.53 这个主机中的资源 app1/servlet , javascript 代码如下所示：12345678910111213&lt;script type=\"text/javascript\"&gt; function request() &#123; var url = 'http://10.1.10.53:8080/app1/servlet'; xmlhttp = new XMLHttpRequest(); // 允许浏览器发送cookie /* xmlhttp.withCredentials = true; */ xmlhttp.open(\"GET\", url, false); xmlhttp.send(); xmlDoc = xmlhttp.responseXML; console.log(xmlDoc); &#125; request();&lt;/script&gt; 当然，如果你想通过jquery来进行ajax请求，代码就应该像下面这样：1234567891011121314151617&lt;script type=\"text/javascript\"&gt; function ajaxRequest() &#123; $.ajax(&#123; url : \"http://10.1.10.53:8080/app1/servlet\", success : function(data, textStatus, jqXHR) &#123; console.log(data); &#125;, error : function(XMLHttpRequest, textStatus, errorThrown) &#123; if (XMLHttpRequest.status &amp;&amp; XMLHttpRequest.status == 404) &#123; Exception.showException(XMLHttpRequest.responseText); &#125; throw new Error(genErrorMsg(XMLHttpRequest, requestUrl)); &#125; &#125;); &#125; ajaxRequest();&lt;/script&gt; 服务器若想使用CORS进行跨域请求，服务器要提供一定的支持。即只需要在返回头中添加字段 Access-Control-Allow-Origin 即可，因此你的服务器端 servlet 代码应该形似下面这样：123456789// 设置跨域请求头response.addHeader(\"Access-Control-Allow-Origin\", \"*\");// 返回文本数据response.setContentType(\"text/xml;charset=UTF-8\");// 写入内容到客户端ServletOutputStream outputStream = response.getOutputStream();outputStream.write(\"&lt;app1&gt;&lt;/app1&gt;\".getBytes(\"utf-8\"));outputStream.flush();outputStream.close(); 注意，使用字段 Access-Control-Allow-Origin 应注意以下几点： 这个字段的值表示所接受的请求的域，形如 http://ip:port 。 若该字段的值为 * ，则表示服务器接收所有的域请求。这样是很危险的，一般我们将这个值设置为指定的、符合我们要求的域。 总结使用CORS很简单，总结起来就两句话而已：客户端代码正常请求，服务器添加返回头 Access-Control-Allow-Origin。 参考跨域资源共享 CORS 详解","categories":[{"name":"2017","slug":"2017","permalink":"http://www.shifeiqi.top/categories/2017/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.shifeiqi.top/tags/JAVA/"},{"name":"CROS","slug":"CROS","permalink":"http://www.shifeiqi.top/tags/CROS/"},{"name":"浏览器","slug":"浏览器","permalink":"http://www.shifeiqi.top/tags/浏览器/"},{"name":"跨域","slug":"跨域","permalink":"http://www.shifeiqi.top/tags/跨域/"}]}]}