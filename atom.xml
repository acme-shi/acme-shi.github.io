<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凌云的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.shifeiqi.top/"/>
  <updated>2019-03-02T06:59:01.674Z</updated>
  <id>http://www.shifeiqi.top/</id>
  
  <author>
    <name>凌云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.shifeiqi.top/2019/03/02/hello-world/"/>
    <id>http://www.shifeiqi.top/2019/03/02/hello-world/</id>
    <published>2019-03-02T06:59:01.674Z</published>
    <updated>2019-03-02T06:59:01.674Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://www.shifeiqi.top/2019/02/11/2021-01-31-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.shifeiqi.top/2019/02/11/2021-01-31-快速排序/</id>
    <published>2019-02-11T08:29:00.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="🐶-原理"><a href="#🐶-原理" class="headerlink" title="🐶 原理"></a>🐶 原理</h3><p>  快速排序属于交换排序的一种，使用<code>分治策略</code>把一个序列分为两个子序列，思路如下：  </p><ol><li><code>基准&lt;pivot&gt;</code>选取,从待排序序列中挑出一个元素，称之为”基准”(pivot)，一般选择队列中第一个元素或者最后一个元素。</li><li><code>分割&lt;partition&gt;</code>操作, 所有比基准小的元素都被交换在基准前面，所有比基准大的元素都被交换到基准后面，分割结束之后，该基准就处于数列的中间位置。</li><li><code>递归</code>地对小于基准值元素的子序列和大于基准值元素的子序列排序进行快速排序.</li></ol><h3 id="🐰-示例"><a href="#🐰-示例" class="headerlink" title="🐰 示例"></a>🐰 示例</h3><p>以下示例模拟对 [1, 6, 2, 8, 4, 3, 7, 9, 5] 进行快速排序过程, 基准<pivot>选择待排序列的最后一个值.</pivot></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00</span></span><br><span class="line">       [<span class="number">1</span>,  <span class="number">6</span>,  <span class="number">2</span>,  <span class="number">8</span>,  <span class="number">4</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">9</span>,  <span class="number">5</span>]</span><br><span class="line">                                        ^pivot</span><br><span class="line"></span><br><span class="line">                                  <span class="comment">// 队列[1,6,2,8,4,3,7,9,5]选取基准5,进行第一次递归分割</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">0x01</span></span><br><span class="line">       [----比<span class="number">5</span>小-----]          [----比<span class="number">5</span>大-----]</span><br><span class="line">       [<span class="number">1</span>,  <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">4</span>,    &lt;<span class="number">5</span>&gt;,    <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">9</span>,  <span class="number">6</span>]  </span><br><span class="line"></span><br><span class="line">                                 <span class="comment">// 第一次递归分割结束,获得两个子队列</span></span><br><span class="line">                                 <span class="comment">// 队列[1,6,2,8,4,3,7,9,5]被基准5分割为[1,3,2,4]和[8,7,9,6]</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">0x10</span></span><br><span class="line">       [             ]           [             ]</span><br><span class="line">       [<span class="number">1</span>,  <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">4</span>,    &lt;<span class="number">5</span>&gt;,    <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">9</span>,  <span class="number">6</span>]</span><br><span class="line">                    ^pivot                    ^pivot</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 对待分割子队列[1,3,2,4]选取基准4,进入第二次递归分割,</span></span><br><span class="line">                                <span class="comment">// 对待分割子队列[8,7,9,6]选取基准6,进入第二次递归分割</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">0x11</span></span><br><span class="line">       [--比<span class="number">4</span>小--]       []      []      [--比<span class="number">6</span>大---]</span><br><span class="line">       [<span class="number">1</span>,  <span class="number">3</span>,  <span class="number">2</span>,  &lt;<span class="number">4</span>&gt;,    &lt;<span class="number">5</span>&gt;,    &lt;<span class="number">6</span>&gt;,  <span class="number">7</span>,  <span class="number">9</span>,  <span class="number">8</span>]</span><br><span class="line">                                <span class="comment">// 第二次递归分割结束,获得四个子队列</span></span><br><span class="line">                                <span class="comment">// [1,3,2,4]被4分割为 [1,3,2] 和 []</span></span><br><span class="line">                                <span class="comment">// [8,7,9,6]被6分割为 [] 和 [7,9,6]</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">0x20</span></span><br><span class="line">       [          ]       []      []      [         ]</span><br><span class="line">       [<span class="number">1</span>,  <span class="number">3</span>,  <span class="number">2</span>,   &lt;<span class="number">4</span>&gt;,    &lt;<span class="number">5</span>&gt;,    &lt;<span class="number">6</span>&gt;,  <span class="number">7</span>,  <span class="number">9</span>,  <span class="number">8</span>]</span><br><span class="line">                ^pivot                             ^pivot</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 子队列[1,3,2]选取基准2,进入第三次递归分割</span></span><br><span class="line">                                <span class="comment">// 子队列[7,9,8]选取基准8,进入第三次递归分割</span></span><br><span class="line">                                <span class="comment">// []不做处理</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">0x21</span></span><br><span class="line">       [-]       [-]                        [-]       [-]</span><br><span class="line">       [<span class="number">1</span>,  &lt;<span class="number">2</span>&gt;,  <span class="number">3</span>,   &lt;<span class="number">4</span>&gt;,    &lt;<span class="number">5</span>&gt;,    &lt;<span class="number">6</span>&gt;,  <span class="number">7</span>,  &lt;<span class="number">8</span>&gt;,  <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 第三次递归分割结束,获取4个子队列</span></span><br><span class="line">                                <span class="comment">// [1,3,2]被3分割为[1]和[3]</span></span><br><span class="line">                                <span class="comment">// [7,9,8]被8分割为[7]和[9]</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">0x30</span>      </span><br><span class="line">      [-]       [-]                        [-]       [-]</span><br><span class="line">      [<span class="number">1</span>,  &lt;<span class="number">2</span>&gt;,  <span class="number">3</span>,   &lt;<span class="number">4</span>&gt;,    &lt;<span class="number">5</span>&gt;,    &lt;<span class="number">6</span>&gt;,  <span class="number">7</span>,  &lt;<span class="number">8</span>&gt;,  <span class="number">9</span>]</span><br><span class="line">       ^pivot    ^pivot                     ^pivot    ^pivot</span><br><span class="line"></span><br><span class="line">                               <span class="comment">// 子队列[1] [3] [7] [9] 都只包含一个基准元素,直接返回.</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">0x31</span></span><br><span class="line">      [&lt;<span class="number">1</span>&gt;,  &lt;<span class="number">2</span>&gt;,  &lt;<span class="number">3</span>&gt;,   &lt;<span class="number">4</span>&gt;,  &lt;<span class="number">5</span>&gt;,  &lt;<span class="number">6</span>&gt;,  &lt;<span class="number">7</span>&gt;,  &lt;<span class="number">8</span>&gt;,  &lt;<span class="number">9</span>&gt;]</span><br><span class="line"></span><br><span class="line">                              <span class="comment">// 获得排好队列</span></span><br></pre></td></tr></table></figure><h3 id="🐗-实现"><a href="#🐗-实现" class="headerlink" title="🐗 实现"></a>🐗 实现</h3><ul><li><p>Java 递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap func</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lIndex, <span class="keyword">int</span> rIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = array[lIndex];</span><br><span class="line">    array[lIndex] = array[rIndex];</span><br><span class="line">    array[rIndex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition func</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选取基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = array[right];</span><br><span class="line">    <span class="keyword">int</span> sIndex = right;</span><br><span class="line">    <span class="comment">// 分割</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(array[left] &lt;= pivot &amp;&amp; left &lt; right)</span><br><span class="line">            left ++;</span><br><span class="line">        swap(array, left, sIndex);</span><br><span class="line">        sIndex = left;</span><br><span class="line">        <span class="comment">// --</span></span><br><span class="line">        <span class="keyword">while</span>(array[right] &gt;= pivot &amp;&amp; left &lt; right)</span><br><span class="line">            right --;</span><br><span class="line">        swap(array, sIndex, right);</span><br><span class="line">        sIndex = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// quick sort, recursively func</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> parIndex = partition(array, left, right);</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    quickSort(array, left, parIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(array, parIndex + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sort interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JavaScript 递归实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap func</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">array, lIndex, rIndex</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> tmp = array[lIndex];</span><br><span class="line">  array[lIndex] = array[rIndex];</span><br><span class="line">  array[rIndex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition func</span></span><br><span class="line"><span class="keyword">const</span> partition = <span class="function">(<span class="params">array, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 选择基准</span></span><br><span class="line">  <span class="keyword">const</span> pivot = array[right];</span><br><span class="line">  <span class="keyword">let</span> sIndex = right;</span><br><span class="line">  <span class="comment">// 分割</span></span><br><span class="line">  <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">while</span>(array[left] &lt;= pivot &amp;&amp; left &lt; right)</span><br><span class="line">      left++;</span><br><span class="line">    swap(array, left, sIndex);</span><br><span class="line">    sIndex = left;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">while</span>(array[right] &gt;= pivot &amp;&amp; left &lt; right)</span><br><span class="line">      right--;</span><br><span class="line">    swap(array, sIndex, right);</span><br><span class="line">    sIndex = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// quick sort, recursively func</span></span><br><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">array, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> parIndex = partition(array, left, right);</span><br><span class="line">  quickSort(array, left, parIndex - <span class="number">1</span>);</span><br><span class="line">  quickSort(array, parIndex + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sort interface func</span></span><br><span class="line"><span class="keyword">const</span> sort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> array = nums.slice();</span><br><span class="line">  quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;🐶-原理&quot;&gt;&lt;a href=&quot;#🐶-原理&quot; class=&quot;headerlink&quot; title=&quot;🐶 原理&quot;&gt;&lt;/a&gt;🐶 原理&lt;/h3&gt;&lt;p&gt;  快速排序属于交换排序的一种，使用&lt;code&gt;分治策略&lt;/code&gt;把一个序列分为两个子序列，思路如下：  &lt;/p
      
    
    </summary>
    
      <category term="2019" scheme="http://www.shifeiqi.top/categories/2019/"/>
    
    
      <category term="算法" scheme="http://www.shifeiqi.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://www.shifeiqi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://www.shifeiqi.top/2019/02/11/2020-01-31-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.shifeiqi.top/2019/02/11/2020-01-31-冒泡排序/</id>
    <published>2019-02-11T07:58:00.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="💣-原理"><a href="#💣-原理" class="headerlink" title="💣 原理"></a>💣 原理</h3><ul><li><p>冒泡排序基本思想：  </p><ol><li>将待排序队列分为<code>未排序子队列</code>（位于左侧，初始值为待排序队列）和<code>已排序子队列</code>（位于右侧，初始值为空）。</li><li>走访<code>未排序子队列</code>，选择<code>未排序子队列</code>中的最大值交换到<code>未排序子队列</code>的列尾。</li><li><code>未排序子队列</code>长度减一， <code>已排序子队列</code>长度加一。</li><li><code>未排序子队列</code>长度 == 0 ?  排序结束 ：  重复第2步。  </li></ol></li><li><p>时间复杂度：<code>O(n^2)。</code>  </p></li><li>稳定。</li></ul><h3 id="🔫-示例"><a href="#🔫-示例" class="headerlink" title="🔫 示例"></a>🔫 示例</h3><p>  以下是对队列 <code>[4, 2, 3, 6, 8, 1, 5]</code> 进行冒泡排序的模拟过程（注：算法抽象过程描述，非程序运行过程）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>     [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span> ]</span><br><span class="line">      [    未排序子队列     ] [已排序子队列]    <span class="comment">// 将待排序队列分为 [未排序子队列] 和 [已排序子队列]</span></span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">1</span>     [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>,    <span class="number">1</span>, <span class="number">5</span>,   <span class="number">8</span>]</span><br><span class="line">      [    未排序子队列     ] [已排序子队列]    <span class="comment">//第1次走访，</span></span><br><span class="line">                                              <span class="comment">//选取当前未排序子队列中最大值8冒泡到最后</span></span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">2</span>     [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>,       <span class="number">1</span>, <span class="number">5</span>,   <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">      [    未排序子队列     ] [已排序子队列]    <span class="comment">//第2次走访，</span></span><br><span class="line">                                              <span class="comment">//选取当前未排序子队列中最大值6冒泡到最后</span></span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">3</span>     [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>,       <span class="number">1</span>,      <span class="number">5</span>,  <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">      [    未排序子队列     ] [已排序子队列]    <span class="comment">//第3次走访，</span></span><br><span class="line">                                              <span class="comment">//选取当前未排序子队列中最大值5冒泡到最后</span></span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">4</span>     [   <span class="number">2</span>, <span class="number">3</span>,       <span class="number">1</span>,      <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">      [    未排序子队列     ] [已排序子队列]    <span class="comment">//第4次走访，</span></span><br><span class="line">                                              <span class="comment">//选取当前未排序子队列中最大值4冒泡到最后</span></span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">5</span>     [   <span class="number">2</span>,          <span class="number">1</span>,      <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">      [    未排序子队列     ] [已排序子队列]    <span class="comment">//第5次走访，</span></span><br><span class="line">                                              <span class="comment">//选取当前未排序子队列中最大值3冒泡到最后</span></span><br><span class="line">------------------------------------------------------------------------------------                                              </span><br><span class="line"><span class="number">6</span>     [               <span class="number">1</span>,      <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">      [    未排序子队列     ] [已排序子队列]    <span class="comment">//第6次走访，</span></span><br><span class="line">                                              <span class="comment">//选取当前未排序子队列中最大值2冒泡到最后</span></span><br><span class="line">------------------------------------------------------------------------------------                                              </span><br><span class="line"><span class="number">7</span>     [                       <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">      [    未排序子队列     ] [已排序子队列]    <span class="comment">//第7次走访，</span></span><br><span class="line">                                              <span class="comment">//选取当前未排序子队列中最大值1冒泡到最后</span></span><br></pre></td></tr></table></figure></p><h3 id="🔪-算法实现"><a href="#🔪-算法实现" class="headerlink" title="🔪 算法实现"></a>🔪 算法实现</h3><ul><li><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lIndex, <span class="keyword">int</span> rIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = array[lIndex];</span><br><span class="line">    array[lIndex] = array[rIndex];</span><br><span class="line">    array[rIndex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sort interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    <span class="comment">// bubble sort</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>])</span><br><span class="line">                swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">array, lIndex, rIndex</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = array[lIndex];</span><br><span class="line">    array[lIndex] = array[rIndex];</span><br><span class="line">    array[rIndex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sort interface</span></span><br><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> array = nums.slice();</span><br><span class="line">    <span class="comment">// bubble sort</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++)</span><br><span class="line">      <span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>])</span><br><span class="line">        swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;💣-原理&quot;&gt;&lt;a href=&quot;#💣-原理&quot; class=&quot;headerlink&quot; title=&quot;💣 原理&quot;&gt;&lt;/a&gt;💣 原理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;冒泡排序基本思想：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将待排序队列分为&lt;code&gt;未排序子队列&lt;/co
      
    
    </summary>
    
      <category term="2019" scheme="http://www.shifeiqi.top/categories/2019/"/>
    
    
      <category term="算法" scheme="http://www.shifeiqi.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://www.shifeiqi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>写在2019</title>
    <link href="http://www.shifeiqi.top/2019/01/31/2019-01-31-%E5%86%99%E5%9C%A82019/"/>
    <id>http://www.shifeiqi.top/2019/01/31/2019-01-31-写在2019/</id>
    <published>2019-01-31T08:21:00.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<p>还有一个小时就要下班了，对着电脑大眼瞪小屏已经一下午，什么也没看下去，什么也没写出来。索性趁着这一个小时，写点2019年要干的事吧。<br>想想2018年都已经过去了，好的坏的都来过，该想起该忘记的还是那个样子，索性就让这个本命年就这样过去吧，年终总结就不写了。<br>随手写的随笔，格式就不那么严格了。</p><p>2019已经过去一个月了，还有11个月，时间还是挺漫长的，而我又是个急性子，计划一年的事情有点难为。倒不是说我做不到，而是想想一年要做的事情肯定有好多，容易让人焦虑。索性先列出前半年的计划，等到今年6月份再出下半年的计划，应该是没什么问题的。</p><h1 id="1-精神混蛋"><a href="#1-精神混蛋" class="headerlink" title="1. 精神混蛋"></a>1. 精神混蛋</h1><h3 id="1-1-看书"><a href="#1-1-看书" class="headerlink" title="1.1 看书"></a>1.1 看书</h3><p>总之就看书吧，书单我没有想过，摸到哪本看哪本吧。<br>看我那本还剩下三分之二的《百年孤独》；看那本卖了好久只翻过第一页的《流浪地球》；看那本心心念念但是一直没有买的《人类简史》；甚至于说看那一套念叨了好久的《冰与火之歌》。<br>总之就是看书吧。  </p><h3 id="1-2-刷剧"><a href="#1-2-刷剧" class="headerlink" title="1.2 刷剧"></a>1.2 刷剧</h3><p>整个18年都没有好好地看过一整部，上半年打算把《冰与火之歌》或者《夺命毒师》或者《越狱》重新看一遍。这次要看全英文版的。</p><h1 id="2-技术"><a href="#2-技术" class="headerlink" title="2. 技术"></a>2. 技术</h1><p>入前端坑应该已经有大半年了，总觉得前端是一块刚刚开垦的地，需要新的拖拉机。2019年上半年的精力主要会集中在前端领域，更加深入地取了解学习前端。  </p><h3 id="2-1-函数式编程"><a href="#2-1-函数式编程" class="headerlink" title="2.1 函数式编程"></a>2.1 函数式编程</h3><p>不仅仅是学习如何在JavaScript中使用这个模式，而是要深入学习这种思想，有必要的话可能会上 haskell 和《范畴论》。</p><h3 id="2-2-编译原理"><a href="#2-2-编译原理" class="headerlink" title="2.2 编译原理"></a>2.2 编译原理</h3><p>重新温习编译原理吧，算是为深入了解前端底层打个基础啥的。<br>《龙书》和红皮书要看完。</p><h3 id="2-3-机器学习"><a href="#2-3-机器学习" class="headerlink" title="2.3 机器学习"></a>2.3 机器学习</h3><p>上半年应该会在机器学习方面入个门，毕竟这么火的技术不了解以下实在是可惜了。<br>这个东西应该是会和我的老伙计一块学。</p><h3 id="2-4写博客和做开源"><a href="#2-4写博客和做开源" class="headerlink" title="2.4写博客和做开源"></a>2.4写博客和做开源</h3><p>这个没啥好说的，show code &amp; pub blog 吧。</p><h1 id="3-身体"><a href="#3-身体" class="headerlink" title="3. 身体"></a>3. 身体</h1><p>身体真的很重要，2018年有一段时间晚上睡觉之前我都在想第二天还能不能醒过来。今年上半年的干的事就从最简单的跑步开始吧，嗯还要增重，太瘦了走路都没有安全感。按时吃饭，按时睡觉。</p><h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h1><p>上半年可能会出去走一趟，有可能是北京，有可能是长三角，也有可能是深圳。或者是海南和成都，甚至是西藏。目前还不确定，到时候再说吧。</p><p>就到这吧。 :)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还有一个小时就要下班了，对着电脑大眼瞪小屏已经一下午，什么也没看下去，什么也没写出来。索性趁着这一个小时，写点2019年要干的事吧。&lt;br&gt;想想2018年都已经过去了，好的坏的都来过，该想起该忘记的还是那个样子，索性就让这个本命年就这样过去吧，年终总结就不写了。&lt;br&gt;随手
      
    
    </summary>
    
      <category term="2019" scheme="http://www.shifeiqi.top/categories/2019/"/>
    
    
      <category term="日志" scheme="http://www.shifeiqi.top/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://www.shifeiqi.top/2018/10/16/2018-10-16-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.shifeiqi.top/2018/10/16/2018-10-16-代理模式/</id>
    <published>2018-10-16T07:36:00.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理模式概述"><a href="#代理模式概述" class="headerlink" title="代理模式概述"></a>代理模式概述</h1><p>代理模式作为一种结构型设计模式，同时也是GoF所提的23中设计模式之一，在我们日常开发中大量被使用(远程代理、AOP等等)。本章将对代理模式的原理及设计思想进行介绍。</p><h3 id="代理模式定义"><a href="#代理模式定义" class="headerlink" title="代理模式定义"></a>代理模式定义</h3><p>Provide a surrogate or placeholder for another object to control access to it.<br>为其他对象提供一个代理对象用来控制对这个对象的访问。</p><h3 id="代理模式简介"><a href="#代理模式简介" class="headerlink" title="代理模式简介"></a>代理模式简介</h3><p>开始介绍代理模式之前读者需要熟悉以下概念：</p><ul><li>代理对象（Proxy）：用来代理真实对象，对真实对象的接口进行访问控制。</li><li>真实对象（RealSubject）：被代理对象，真正对外提供业务接口的对象。</li></ul><p>代理模式的设计思路是在访问者和真实对象之间提供一个中间层（代理对象），用来对真实对象的业务接口进行包装。基于这个原理，代理对象在对真实对象的业务接口进行包装的时候可以提供额外的功能，比如：调用者的访问权限控制，日志记录等等。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/10/16/2018-10-16-代理模式/medias/images/code/java_design_pattern/proxy/proxy-pattern-01.png" alt="proxy-pattern-01" title>                </div>                <div class="image-caption">proxy-pattern-01</div>            </figure>  <h3 id="代理模式分类"><a href="#代理模式分类" class="headerlink" title="代理模式分类"></a>代理模式分类</h3><p>按照代理对象的类模板的创建时机，代理模式可以分为静态代理和动态代理。</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>静态代理是指用于创建代理对象的类模板在编译期之前创建的，说的通俗一点，用于创建代理对象的类模板是由开发者手动编写的。（注：笔者以为静态代理叫做静态模板代理更容易理解一些）</p><h3 id="通用设计"><a href="#通用设计" class="headerlink" title="通用设计"></a>通用设计</h3><p>本小节将介绍一个比较通用的静态代理实现方式。</p><ul><li>类图<br><img src="/2018/10/16/2018-10-16-代理模式/medias/images/code/java_design_pattern/proxy/proxy-pattern-02.png" alt="proxy-pattern-01">  </li><li>实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实类模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"real subject : do something!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">// 代理对象可通过ICO容器注入等配合使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"proxy subject : before do"</span>);</span><br><span class="line">        subject.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"proxy subject : after  do"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        Subject proxy = <span class="keyword">new</span> Proxy(<span class="keyword">new</span> RealSubject());</span><br><span class="line">        <span class="comment">// 调用代理方法</span></span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>动态代理是指用于创建代理对象的类模板是在程序运行期间动态生成的，使用动态代理可以避免静态代理存在的一些问题。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例<jdk 动态代理></jdk></h3><p>这里使用Java动态代理的官方教程来做演示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">doSomething</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实类模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doSomething</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"real subject : do something !"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  动态代理类，重写 &#123;<span class="doctag">@link</span> java.lang.reflect.InvocationHandler#invoke(Object, Method, Object[])&#125;</span></span><br><span class="line"><span class="comment"> *  对真实对象的每一个服务接口进行包装</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.reflect.InvocationHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// real subject</span></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"proxy subject : before"</span>);</span><br><span class="line">        Object result = method.invoke(subject, args);</span><br><span class="line">        System.out.println(<span class="string">"proxy subject : after"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(</span><br><span class="line">            subject.getClass().getClassLoader(),</span><br><span class="line">            subject.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> Proxy(subject)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Subject proxy = (Subject) Proxy.newInstance(<span class="keyword">new</span> RealSubject());</span><br><span class="line">        proxy.doSomething(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://sourcemaking.com/design_patterns/proxy" target="_blank" rel="noopener"><em>Proxy Design Pattern</em></a></li><li><a href="https://github.com/iluwatar/java-design-patterns/tree/master/proxy" target="_blank" rel="noopener"><em>java-design-pattern</em></a></li><li><a href="http://www.runoob.com/design-pattern/proxy-pattern.html" target="_blank" rel="noopener"><em>代理模式</em></a>  </li><li><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="noopener"><em>设计模式之禅</em></a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener"><em>Dynamic Proxy Classes</em></a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代理模式概述&quot;&gt;&lt;a href=&quot;#代理模式概述&quot; class=&quot;headerlink&quot; title=&quot;代理模式概述&quot;&gt;&lt;/a&gt;代理模式概述&lt;/h1&gt;&lt;p&gt;代理模式作为一种结构型设计模式，同时也是GoF所提的23中设计模式之一，在我们日常开发中大量被使用(远程代理
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="设计模式" scheme="http://www.shifeiqi.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://www.shifeiqi.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Proxy" scheme="http://www.shifeiqi.top/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>控制反转(IOC)</title>
    <link href="http://www.shifeiqi.top/2018/08/26/2018-08-26-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC(IOC)/"/>
    <id>http://www.shifeiqi.top/2018/08/26/2018-08-26-控制反转(IOC)/</id>
    <published>2018-08-26T06:28:00.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>后端应用程序架构开发中，Spring是一个不得不迈过去的门槛。而对于学习和使用Spring，IOC又是一个不得不迈过去的门槛。  </p><p>在此先简单解释一下什么是依赖：</p><ul><li>依赖是什么？<br>这里所解释的依赖是一个泛化的概念，即表示一个类依赖于另外一个类的定义。依赖对应Java类中的成员变量，局部变量，参数等等。对应的软件工程中的类图如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/26/2018-08-26-控制反转(IOC)/medias/images/code/ioc/dependency-example.png" alt="dependency-example" title>                </div>                <div class="image-caption">dependency-example</div>            </figure>其中一个比较常见的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// B称之为A的依赖</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="无IOC架构"><a href="#无IOC架构" class="headerlink" title="无IOC架构"></a>无IOC架构</h1><p>现在假设我们要从头开始架构一个应用系统App，因为业务需要使用了底层框架组件A(三方jar或者底层框架模块)，那么一个比较常见的架构如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/26/2018-08-26-控制反转(IOC)/medias/images/code/ioc/dependency-normal.png" alt="dependency-normal" title>                </div>                <div class="image-caption">dependency-normal</div>            </figure><p>由上图可以看出，App不仅依赖组件接口A，而且接口A的实现AImpl由应用程序创建。根据该架构图完成的编码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A接口，为组件制定规范</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AImpl</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用程序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> AImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在考虑这么两种情况：</p><ol><li>在开发过程中发现组件的实现AImpl不能满足现有的业务需求，需要将其换成A的另一个实现类AImplForNormal。</li><li>该系统需要在山东和山西地区同时上线，但是根据需求需要在山东使用组件A的实现类AImplForSD，在山西需要使用组件的实现类AImplForSX。    </li></ol><p>解决第一种情况的最笨办法就是将应用程序App中所有关于A的创建语句更改为<code>A a = new AImplForNormal();</code>，但是如果这样的语句有成千上万条，这必然不是一个好方法。<br>解决第二种情况大约有这么两种笨方法: 在组件A的赋值语句中添加地区判断，或者为山东和山西地区写两套App系统代码，但这无疑都是馊主意。</p><p>其实上述两个问题归根结底只是一个问题：<em>如何动态地创建App所依赖的 组件A的子类。即如何在应用程序运行期间选择性地去创建组件依赖对象，让被依赖对象能够像插件一样根据配置来进行插拔处理。</em></p><h1 id="IOC架构"><a href="#IOC架构" class="headerlink" title="IOC架构"></a>IOC架构</h1><p>现在我们根据引入IOC，来重新架构应用系统App。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/26/2018-08-26-控制反转(IOC)/medias/images/code/ioc/ioc-normal.png" alt="ioc-normal" title>                </div>                <div class="image-caption">ioc-normal</div>            </figure><p>可以看出，应用程序仅仅依赖接口和IOC容器，而组件接口A的实现类由IOC容器根据配置有选择地创建。根据该架构完成的编码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A接口，为组件制定规范</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AImpl</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AImplForNormal</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AImplForSD</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AImplForSX</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// IOC容器类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCContainer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getA</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 读取应用程序配置文件,假设读取到的配置信息是 com.cloudups.AImplForNormal</span></span><br><span class="line">        String className = <span class="string">"com.cloudups.AImplForNormal"</span>;</span><br><span class="line">        <span class="keyword">return</span> (A) Class.forName(className).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用程序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a = IOCContainer.getA();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上述编码和架构图可以看出，组件接口A的实例对象可以由IOC容器在程序运行过程中根据配置文件有选择地进行创建，所以对于上文中的第一个问题，在开发过程中在配置文件中配置A的实现类<code>AImplFornormal</code>即可；而对于第二个问题，则在山东地区部署的时候修改配置文件中A的实现类为<code>AImplForSD</code>，在山西部署的时候修改配置文件中A的实现类为<code>AImplForSX</code>即可。  </p><p>引入IOC容器之后的架构模式可以解决一个很棘手的问题：在程序运行期间根据配置有选择地创建组件的子对象。<code>即将对象的创建权交给容器&lt;框架&gt;来完成，而不是由应用程序来创建对象。这就是所谓的控制反转&lt;IOC&gt;。`</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Inversion of Control Containers and the Dependency Injection pattern</a></li><li><a href="/medias/doc/ioc/IOC容器和DI模式.zip">控制反转和依赖注入-中文翻译</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;后端应用程序架构开发中，Spring是一个不得不迈过去的门槛。而对于学习和使用Spring，IOC又是一个不得不迈过去的门槛
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="控制反转" scheme="http://www.shifeiqi.top/tags/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
      <category term="IOC" scheme="http://www.shifeiqi.top/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>Java-for-each-基础</title>
    <link href="http://www.shifeiqi.top/2018/08/21/2018-08-21-Java-for-each-%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.shifeiqi.top/2018/08/21/2018-08-21-Java-for-each-基础/</id>
    <published>2018-08-21T13:55:00.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><code>for-each loop</code>是JDK1.5增加的特性，其目的是为了更优雅简洁地迭代<em>数组</em>或者<em>集合</em>。<br><code>for-each</code> 的意思是指 <code>for each item in container</code>（没想到好的翻译）。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><code>for-each</code> 结构一般用来迭代 <em>数组</em>、<em>容器</em>、<em>Iterable接口的子类</em>，一般<code>for-each</code>结构如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object item : items) &#123;</span><br><span class="line">  <span class="comment">// do something for item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>迭代数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] items = &#123;<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String item : items) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代容器    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; items = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>);</span><br><span class="line"><span class="keyword">for</span>(String item : items) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代Iterable接口的子类<br>JDK1.5 规定凡是实现了Iterable接口的类都可以用<code>for-each</code>进行迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IContainer</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 子元素集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写Iterable接口方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> index &lt; IContainer.<span class="keyword">this</span>.items.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> IContainer.<span class="keyword">this</span>.items.get(index++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化容器</span></span><br><span class="line">    IContainer iContainer = <span class="keyword">new</span> IContainer();</span><br><span class="line">    iContainer.add(<span class="string">"apple"</span>);</span><br><span class="line">    iContainer.add(<span class="string">"orange"</span>);</span><br><span class="line">    iContainer.add(<span class="string">"banana"</span>);</span><br><span class="line">    <span class="comment">// for-each迭代容器</span></span><br><span class="line">    <span class="keyword">for</span>(String item : iContainer) &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：用<code>for-each</code>迭代容器和迭代Iterable子类是一个原理，因为容器类实现了接口Iterable。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>for-each</code>结构在编译期间会被编译器进行处理，最终被替换为真正的迭代结构，以下将以数组和容器说明<code>for-each</code>原理。</p><ul><li><p><code>for-each</code>迭代数组原理<br>编译器会根据数组下标将<code>for-each</code>结构优化为真正的遍历结构，如下：<br>开发人员的<code>for-each</code>代码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  String[] items = &#123;<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(String item : items) &#123;</span><br><span class="line">      System.out.println(item);</span><br><span class="line">  &#125;</span><br><span class="line">```  </span><br><span class="line">经过编译器优化后的代码:  </span><br><span class="line">```java</span><br><span class="line">  String[] items = &#123;<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; items.length; i++) &#123;</span><br><span class="line">      String item = items[i];</span><br><span class="line">      System.out.println(item);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>for-each</code> 迭代容器原理<br>编译器会使用容器的迭代器（Iterator）对容器迭代进行处理。如下：<br>开发人员的<code>for-each</code>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; items = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>);</span><br><span class="line"><span class="keyword">for</span>(String item : items) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>经过编译器优化后的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; items = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>);</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; iterator = items.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">    String item = iterator.next();</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Iterable接口详解"><a href="#Iterable接口详解" class="headerlink" title="Iterable接口详解"></a>Iterable接口详解</h1><p>JDK1.5规定，凡是实现了Iterable接口的子类均可以使用<code>for-each</code>结构来进行迭代，下图为Iterable接口类图：   </p><p><img src="/2018/08/21/2018-08-21-Java-for-each-基础/medias/images/code/java-for-each/iterable-urm.png" alt="iterable-urm"><br><code>Iterable</code>接口共三个方法，其中：</p><ul><li><code>iterator(): Iterator&lt;T&gt;</code>: 获取迭代器。</li><li><code>forEach(Consumer&lt;? super T&gt;): void</code>: 遍历容器（JDK1.8新增）。</li><li><code>spliterator(): Spliterator&lt;T&gt;</code>: 获取可分裂迭代器(JDK1.8新增)。</li></ul><h1 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h1><p>事物总有正反两面，<code>for-each</code>也不例外。</p><ul><li>优势<ol><li>代码更优雅简洁</li><li>减少手动遍历发生的逻辑错误。</li></ol></li><li>劣处<ol><li>不能更新容器中的元素，不能删除容器中的元素</li><li>只能串行操作，不能用于并行操作。</li></ol></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">The For-Each Loop</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Interface Iterable<t></t></a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;&lt;code&gt;for-each loop&lt;/code&gt;是JDK1.5增加的特性，其目的是为了更优雅简洁地迭代&lt;em&gt;数组&lt;/e
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="for-each" scheme="http://www.shifeiqi.top/tags/for-each/"/>
    
      <category term="基础" scheme="http://www.shifeiqi.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架分析-Collection</title>
    <link href="http://www.shifeiqi.top/2018/08/20/2018-08-20-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90-Collection/"/>
    <id>http://www.shifeiqi.top/2018/08/20/2018-08-20-Java集合框架分析-Collection/</id>
    <published>2018-08-20T13:55:00.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><code>Collection</code> 接口是<code>collection 继承树</code>的顶级接口，它定义了一系列的单元素容器操作的规范。这些规范大致可以分为四类：数据增加、数据删除、数据查找、其他。</p><h1 id="URM"><a href="#URM" class="headerlink" title="URM"></a>URM</h1><p>例行往事，先上类图:  </p><p><img src="/2018/08/20/2018-08-20-Java集合框架分析-Collection/medias/images/code/java-collections-framework/collection/java-collection-urm.png" alt="java-collection-urm.png"></p><p>其中，<code>Collection</code>接口继承接口<code>Iterable</code>，表示<code>Collection</code>允许使用<code>for-each</code>结构进行迭代遍历。<br><code>Collection</code>接口所定义规范解释如下：  </p><ul><li>数据增加</li><li>数据删除</li><li>数据查找</li><li>其他</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt; 接口是&lt;code&gt;collection 继承树&lt;/code&gt;的顶级接口，它定
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="集合框架" scheme="http://www.shifeiqi.top/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码分析" scheme="http://www.shifeiqi.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Collection" scheme="http://www.shifeiqi.top/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架分析-Map</title>
    <link href="http://www.shifeiqi.top/2018/08/19/2018-08-19-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90-Map/"/>
    <id>http://www.shifeiqi.top/2018/08/19/2018-08-19-Java集合框架分析-Map/</id>
    <published>2018-08-19T13:55:00.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>关于Java集合框架(Java Collections Framework)， 本应该早就动笔总结了，奈何已经被我充分重视但还是不够足够重视的Java集合框架牵涉的知识点太多，加之JDK 1.8引入的<code>函数式</code>导致笔者又一次深陷技术研究多日。  </p><h1 id="URM"><a href="#URM" class="headerlink" title="URM"></a>URM</h1><p>例行往事，先上类图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/19/2018-08-19-Java集合框架分析-Map/medias/images/code/java-collections-framework/map/java-map-urm.png" alt="java-design-pattern-iterator" title>                </div>                <div class="image-caption">java-design-pattern-iterator</div>            </figure>  <p>以上类图根据JDK1.8源码绘制，该类图为具体实现&lt;HashMap、TreeMap等&gt;制定了一份通用规范。该规范主要有以下：</p><ul><li>定义了<code>键值对</code>存储结构及操作规范(内部接口<code>Entry</code>)。</li><li>定义了<code>键值对容器</code>操作规范(<code>Map</code>)。</li></ul><h1 id="Entry接口分析"><a href="#Entry接口分析" class="headerlink" title="Entry接口分析"></a>Entry接口分析</h1><p><code>Map</code>作为<em>键值对</em>容器， 使用数据结构<code>Entry</code>来描述键值对。接口<code>Map</code>的内部接口<code>Entry</code>定义了通用<em>键值对</em>对外接口规范。如下：</p><ul><li><code>getKey() : K</code> : 获取键。</li><li><code>getValue() : V</code> : 获取值。</li><li><code>setValue(V) : V</code> : 设置值，返回旧值。</li><li><code>comparingByKey() : Comparator&lt;Entry&lt;K, V&gt;&gt;</code> : 获取比较器Comparator（依赖键比较）。</li><li><code>comparingByValue() : Comparator&lt;Entry&lt;K, V&gt;&gt;</code> : 获取比较器Comparator(依赖值比较)。</li><li><code>comparingByKey(Comparator&lt;? super K&gt;) : Comparator&lt;Entry&lt;K, V&gt;&gt;</code> : 获取比较器(使用自定义键比较器)。</li><li><code>comparingByValue(Comparator&lt;? super V&gt;) : Comparator&lt;Entry&lt;K, V&gt;&gt;</code> : 获取比较器(使用自定义值比较器)。</li></ul><h1 id="Map接口分析"><a href="#Map接口分析" class="headerlink" title="Map接口分析"></a>Map接口分析</h1><p><code>Map</code>既然作为集合容器，其提供的功能无外乎就是千年不变的数据操作功能：<em>增加数据</em>、<em>删除数据</em>、<em>查找数据</em>、<em>更新数据</em>。</p><ol><li>Map定义的<em>数据增加</em>接口如下：  <ul><li><code>put(K, V) : V</code> : 将一队键值对放入容器，若存在key，则更新容器中的value</li><li><code>putAll(Map&lt;? extends K, ? extends V&gt;) : void</code> : 将键值对集合放入容器</li><li><code>putAbsent(K, V) : V</code> : 若容器中不存在key，则将该键值对放入容器中</li><li><code>computeIfAbsent(K, Function&lt;? super K, ? extends V&gt;) : V</code> : 若容器中不存在key，则将根据key计算出的value放入容器中。Function为函数接口，用来计算value。</li><li><code>computeIfPresent(K, BiFunction&lt;? super K, ? super V, ? extends V&gt;) : V</code> : 若容器中存在key，则将根据key和oldValue计算出的value放入容器中。BiFunction为函数接口，用来计算value。</li><li><code>compute(K, BiFunction&lt;? super K, ? super V, ? extends V&gt;) : V</code> : 不管容器中存不存在key，都将根据key和oldValue（或者null）计算出来的value放入容器。BiFunction为函数接口，用来计算value。</li><li><code>merge(K, V, BiFunction&lt;? super V, ? super V, ? extends V&gt;) : V</code> : 将oldValue与value计算得到的newValue放入容器。BiFunction为函数接口,用来计算newValue。</li></ul></li><li>Map定义的<em>数据删除</em>接口如下：<ul><li><code>remove(Object) : V</code> : 删除指定key对应的键值对。</li><li><code>remove(Object, Object) : boolean</code> : 删除指定key和value对应的键值对。</li><li><code>clear() : void</code> : 清空容器。</li></ul></li><li>Map定义的<em>数据查询</em>接口如下:<ul><li><code>get(Object) : V</code> : 获取key对应的value。</li><li><code>getOrDefault(Object, V) : V</code> : 获取key对应的value，若容器中不存在该键值对则返回默认值。</li><li><code>keySet() : Set&lt;K&gt;</code> : 返回容器中所有的key。</li><li><code>values() : Collection&lt;V&gt;</code> : 返回容器中所有的value。</li><li><code>entrySet() : Set&lt;Entry&lt;K, V&gt;&gt;</code> : 返回容器中所有的键值对(Entry&lt;K,V&gt;)。</li><li><code>containsKey(Object) : boolean</code> : 查询容器是否包含指定的key。</li><li><code>containsValue(Object) : boolean</code> : 查询容器中是否包含指定的value。</li></ul></li><li>Map定义的<em>数据修改</em>接口如下：<ul><li><code>replace(K, V) : V</code> : 若容器中存在key，则替换key对应的value。</li><li><code>replace(K, V, V) : V</code> : 替换容器中指定的key和value对应的value。</li><li><code>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt;)</code> : 遍历容器，使用函数接口BiFunction去替换键值对。</li></ul></li><li>Map定义的其他接口:<ul><li><code>size() : int</code> : 返回容器当前容量。</li><li><code>isEmpty() : boolean</code> : 查询容器是否为空。</li><li><code>hashCode() : int</code> : 返回容器哈希。</li><li><code>equals(Object) : boolean</code> : 比对方法。</li><li><code>forEach(BiConsumer&lt;? super K, ? super V&gt;) : void</code> : 遍历容器，使用回调函数BiConsumer处理每一对键值对。</li></ul></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>JDK源码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;关于Java集合框架(Java Collections Framework)， 本应该早就动笔总结了，奈何已经被我充分重视但
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="集合框架" scheme="http://www.shifeiqi.top/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码分析" scheme="http://www.shifeiqi.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Map" scheme="http://www.shifeiqi.top/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-迭代器模式</title>
    <link href="http://www.shifeiqi.top/2018/08/16/2018-08-16-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.shifeiqi.top/2018/08/16/2018-08-16-设计模式-迭代器模式/</id>
    <published>2018-08-16T13:55:00.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>小打小闹了一年，最近打算好好写点东西了。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Provide a way to access the elements of an aggregate object sequentially without exposing its<br>underlying representation.<br>提供一种顺序访问容器元素的方法，而又无需暴露容器的内部实现细节。</p><h1 id="URM类图"><a href="#URM类图" class="headerlink" title="URM类图"></a>URM类图</h1><p>这里以Java源码中的迭代器为例。  </p><p><img src="/2018/08/16/2018-08-16-设计模式-迭代器模式/medias/images/code/java_design_pattern/iterator/java-iterator-pattern-urm.png" alt="java-design-pattern-iterator"></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器标志接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 聚合容器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AggregateObject</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 迭代器内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AggregateIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; items.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.get(index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Iterable&lt;String&gt;) <span class="keyword">this</span>.new AggregateIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="noopener"><em>设计模式之禅</em></a></li><li><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener"><em>java-design-patterns</em></a></li><li>JDK 1.8 源码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;小打小闹了一年，最近打算好好写点东西了。&lt;/p&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;head
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="设计模式" scheme="http://www.shifeiqi.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="http://www.shifeiqi.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="http://www.shifeiqi.top/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法模式</title>
    <link href="http://www.shifeiqi.top/2018/08/09/2018-08-09-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.shifeiqi.top/2018/08/09/2018-08-09-设计模式-模板方法模式/</id>
    <published>2018-08-09T06:43:10.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>刚开始读jdk源码的时候感觉哇这代码好乱，为什么子类调父类，父类调子类，跳来跳去的眼睛都花了。。后来才知道，原来那种写法被叫做<em>模板方法模式</em>。  </p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template<br>Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s<br>structure.<br>定义一个操作中的算法的框架， 而将一些步骤延迟到子类中。 使得子类可以不改<br>变一个算法的结构即可重定义该算法的某些特定步骤。</p><h1 id="URM-类图"><a href="#URM-类图" class="headerlink" title="URM 类图"></a>URM 类图</h1><p><em>模板方法模式</em> 的通用类图如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/2018-08-09-设计模式-模板方法模式/medias/images/code/java_design_pattern/template/java-design-pattern-template-urm.png" alt="java-design-pattern-template" title>                </div>                <div class="image-caption">java-design-pattern-template</div>            </figure><p>其中：</p><ul><li><code>AbstractClass</code> 是抽象模板类，其中定义了模板方法，基本操作方法和钩子方法。</li><li><code>ConcreteClassA</code> 具体模板方法，重写基本方法和钩子方法。</li><li><code>operateMethod()</code> 基本操作方法，由子类重写，并且在模板方法中被调用。</li><li><code>templateMethod()</code> 模板方法, 由抽象模板类实现，一般以固定的逻辑调用基本操作方法和钩子方法。</li><li><code>hookMethod()</code> 钩子方法，一般是由抽象模板类提供的空方法，具体模板类可选择性的实现该方法。</li></ul><p>具体思维导图如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/2018-08-09-设计模式-模板方法模式/medias/images/code/java_design_pattern/template/java-design-pattern-template-xmind.png" alt="java-design-pattern-template" title>                </div>                <div class="image-caption">java-design-pattern-template</div>            </figure><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>以下是模板方法模式的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象模板类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本操作方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operateMethod1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operateMethod2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 钩子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 该模板方法的实现逻辑是依次调用基本操作方法和钩子方法</span></span><br><span class="line">        operateMethod1();</span><br><span class="line">        hookMethod();</span><br><span class="line">        operateMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体模板类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClassA</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operateMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写基本操作方法</span></span><br><span class="line">        System.out.println(<span class="string">"ConcreteClassA.operateMethod1()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operateMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写基本操作方法</span></span><br><span class="line">        System.out.println(<span class="string">"ConcreteClassA.operateMethod2()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体模板类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClassB</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operateMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写基本操作方法</span></span><br><span class="line">        System.out.println(<span class="string">"ConcreteClassB.operateMethod1()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operateMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写基本操作方法</span></span><br><span class="line">        System.out.println(<span class="string">"ConcreteClassB.operateMethod2()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写钩子方法</span></span><br><span class="line">        <span class="keyword">super</span>.hookMethod();</span><br><span class="line">        System.out.println(<span class="string">"ConcreteClassB.hookMethod()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass concreteA = <span class="keyword">new</span> ConcreteClassA();</span><br><span class="line">        concreteA.templateMethod();</span><br><span class="line">        AbstractClass concreteB = <span class="keyword">new</span> ConcreteClassB();</span><br><span class="line">        concreteB.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="noopener"><em>设计模式之禅</em></a></li><li><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener"><em>java-design-patterns</em></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;刚开始读jdk源码的时候感觉哇这代码好乱，为什么子类调父类，父类调子类，跳来跳去的眼睛都花了。。后来才知道，原来那种写法被叫
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="设计模式" scheme="http://www.shifeiqi.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="http://www.shifeiqi.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板方法模式" scheme="http://www.shifeiqi.top/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java四种引用方式</title>
    <link href="http://www.shifeiqi.top/2018/08/08/2018-08-08-Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.shifeiqi.top/2018/08/08/2018-08-08-Java四种引用方式/</id>
    <published>2018-08-08T06:33:10.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>自JDK1.2之后，Java对引用的概念进行了扩充，将引用类型分为四种:强引用，软引用，弱引用，虚引用。同时Java还新增了引用队列用来配合四种引用类型使用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/08/2018-08-08-Java四种引用方式/medias/images/code/java-reference/java-reference-xmind.png" alt="引用思维导图" title>                </div>                <div class="image-caption">引用思维导图</div>            </figure><p>其中：</p><ul><li>强引用(Strong Reference)<br>强引用是程序中普遍存在的，类似于<code>Object obj = new Object();</code>, 对于与强引用关联的对象，只要强引用还在，Java虚拟机永远都不会回收。</li><li>软引用(Soft Reference)<br>软引用用来描述一些还有用但是并非必须的对象。对于软引用关联的对象，只有将要发生内存溢出时，Java虚拟机才会回收这些对象。</li><li>弱引用(Weak Reference)<br>弱引用用来描述非必需对象。对于弱引用关联的对象，Java虚拟机只要进行垃圾回收，无论当前内存是否将要溢出，都会释放回收这些对象。</li><li>虚引用(Phantom Reference)<br>虚引用只是用来标志一个对象，以便在对象被Java虚拟机回收释放之后能得到一个通知。虚引用对于对象的生命周期及其他状态并没有什么影响。</li><li>引用队列(Reference Queue)<br>引用队列用来接收系统通知，当Java虚拟机将要回收对象时，虚拟机会将该对象的引用加入到引用队列中，用以通知该对象将要被垃圾回收。</li></ul><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><ul><li><p>强引用<br>一般Java代码中的引用关系即为强引用，如下:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li><li><p>软引用<br>软引用 <code>SoftReference</code> 两种用法：单独使用以及与引用队列配合使用。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//  1. 单独使用软引用，若与软引用关联的对象被垃圾回收，</span></span><br><span class="line"> <span class="comment">//     则通过软引用get方法获取关联的对象为null</span></span><br><span class="line">Reference&lt;Object&gt; reference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line">Object obj = reference.get();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//  2. 软引用与引用队列配合使用，若与软引用关联的对象被垃圾回收</span></span><br><span class="line"> <span class="comment">//    则在对象被垃圾回收之前，软引用会被放入与之关联的引用队列</span></span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">Reference&lt;Object&gt; reference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(<span class="keyword">new</span> Object(), referenceQueue);</span><br><span class="line"><span class="comment">// 获取引用队列中的第一个item</span></span><br><span class="line">Reference refFromQueue = referenceQueue.poll();</span><br></pre></td></tr></table></figure></li><li><p>虚引用<br>虚引用也有两种用法：单独使用以及与引用队列配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//  1. 单独使用弱引用，若与弱引用关联的对象被垃圾回收，</span></span><br><span class="line"> <span class="comment">//     则通过弱引用get方法获取关联的对象为null</span></span><br><span class="line">Reference&lt;Object&gt; reference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line">System.gc(); <span class="comment">// 垃圾回收</span></span><br><span class="line">Object obj = reference.get(); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//  2. r弱引用与引用队列配合使用，若与弱引用关联的对象被垃圾回收</span></span><br><span class="line"> <span class="comment">//    则在对象被垃圾回收之前，弱引用会被放入与之关联的引用队列</span></span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">Reference&lt;Object&gt; reference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(<span class="keyword">new</span> Object(), referenceQueue);</span><br><span class="line">System.gc(); <span class="comment">// 垃圾回收</span></span><br><span class="line">Reference refFromQueue = referenceQueue.poll(); <span class="comment">// 获取入队列的reference</span></span><br><span class="line">Object obj = refFromQueue.get(); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li><li><p>虚引用<br>虚引用只能和引用队列一同使用&lt;毕竟虚引用只是给对象打上一个标志，以便程序能够在对象被垃圾回收之后接收到通知&gt;，具体使用如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 虚引用与引用队列配合使用，若与虚引用关联的对象被垃圾回收</span></span><br><span class="line"> <span class="comment">// 则在对象被垃圾回收之前，虚引用会被放入与之关联的引用队列</span></span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">Reference&lt;Object&gt; reference = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> Object(), referenceQueue);</span><br><span class="line">System.gc(); <span class="comment">// 垃圾回收</span></span><br><span class="line">Reference refFromQueue = referenceQueue.poll(); <span class="comment">// 获取入队列的reference</span></span><br><span class="line">Object obj = refFromQueue.get(); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="源码略读"><a href="#源码略读" class="headerlink" title="源码略读"></a>源码略读</h1><p>说是源码略读，充其量只是介绍其API，等以后有空再补一章源码细读。</p><ul><li>三种引用介绍<br>Jdk1.2 虽然将引用扩充至四种引用类型，但是只提供三套引用类型相关类, 毕竟强引用至死不会被Java虚拟机回收，提供与之相关的Java类毫无意义。简单类图如下所示：<br><img src="/2018/08/08/2018-08-08-Java四种引用方式/medias/images/code/java-reference/java-reference-urm.png" alt="java-reference-urm"><br>其中：<br>对于父类Reference，其中各方法的含义：<ol><li><code>get()</code> 获取与引用关联的对象，若对象被垃圾回收，则返回<code>null</code>。各个子类根据需求重写了该方法。</li><li><code>clear()</code> 清除与之关联的对象，该对象会在下次垃圾回收中被清除回收。</li><li><code>isEnqueued()</code> 查询该引用是否进入引用队列，即与该引用关联的对象是否即将被垃圾回收或者已经被垃圾回收。</li><li><code>enqueue()</code> 将该引用加入到引用队列中去。</li></ol></li><li>引用队列<br>引用队列用来存放即将被垃圾回收的对象的引用以及已经被垃圾回收的对象的引用。该队列内部是一个链表的实现，每次入队列都会在队列头插入节点，每次出队列都会从队列头取出节点，颇有栈的风格。其类图如下：<br><img src="/2018/08/08/2018-08-08-Java四种引用方式/medias/images/code/java-reference/java-reference-queue-urm.png" alt><br>其中，该类个方法介绍如下：<ol><li><code>poll()</code> 从队列中弹出一个引用，若队列为空则立刻返回<code>null</code>。</li><li><code>remove()</code> 删除队列头部节点并返回，若队列为空则一直等到该队列中有节点为止。</li><li><code>remove(long)</code> 删除队列头部节点并返回,若队列为空则等待参数时间并返回。</li></ol></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">深入理解Java虚拟机</a></li><li>JDK 1.8 源码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;自JDK1.2之后，Java对引用的概念进行了扩充，将引用类型分为四种:强引用，软引用，弱引用，虚引用。同时Java还新增了
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="引用方式" scheme="http://www.shifeiqi.top/tags/%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    
      <category term="Reference" scheme="http://www.shifeiqi.top/tags/Reference/"/>
    
  </entry>
  
  <entry>
    <title>Java接口-基础</title>
    <link href="http://www.shifeiqi.top/2018/08/02/2018-08-02-Java%E6%8E%A5%E5%8F%A3-%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.shifeiqi.top/2018/08/02/2018-08-02-Java接口-基础/</id>
    <published>2018-08-02T01:47:10.000Z</published>
    <updated>2019-03-01T14:07:06.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>接口是Java提供的一种非常强大的特性，使用接口机制可以实现封装隔离，将外部调用与内部实现分割开来。<br><em>面向接口编程</em> 是一种极其强大的编程思想，鉴于笔者水平与经验有限，此篇文章只阐述Java中接口相关的基础内容。<br>本篇文章组织结构如下图：  </p><p><img src="/2018/08/02/2018-08-02-Java接口-基础/medias/images/code/java-interface/interface-base-introduce.png" alt="接口基础组织结构"></p><h1 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h1><ul><li><p>接口定义格式<br>Java 中使用关键字 <code>interface</code> 来定义接口，定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [访问权限符] interface 接口名称&#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>接口定义<br>定义一个接口IPerson, 内容为空，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="接口方法定义"><a href="#接口方法定义" class="headerlink" title="接口方法定义"></a>接口方法定义</h1><ul><li>接口方法定义注意  <ol><li>接口方法默认访问权限是 <code>public</code> ，且只能是 <code>public</code>。  </li><li>接口方法只能是实例方法，不能用关键字 <code>static</code> 、<code>final</code> 修饰。（不然子类怎么重写接口方法？）。  </li><li>接口方法是抽象方法，只能定义，不能实现（即不能有方法体）。  </li></ol></li></ul><ul><li><p>接口方法定义格式  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [public] 返回值类型 方法名([参数类型 arg1, 参数类型 arg2 ...]);</span></span><br></pre></td></tr></table></figure></li><li><p>接口方法定义示例<br>定义一个接口 <em>IPerson</em> ，具备接口方法 <em>say</em> 和 <em>run</em> , 如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 第一种形式，显示声明方法访问权限</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="comment">// 第二种形式，使用隐式的方法访问权限 public</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="接口属性定义"><a href="#接口属性定义" class="headerlink" title="接口属性定义"></a>接口属性定义</h1><ul><li>接口属性定义注意<ol><li>接口属性只能被定义为 <code>公有静态常量</code> , 即 <code>public static final</code>。</li></ol></li><li><p>接口属性定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [public] [static] [final] 属性类型 属性名称 = 初始值 ;</span></span><br></pre></td></tr></table></figure></li><li><p>接口属性定义示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示声明属性修饰符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String race = <span class="string">"human"</span>;</span><br><span class="line">    <span class="comment">// 使用隐式的属性修饰符 public static final</span></span><br><span class="line">    String where = <span class="string">"earth"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h1><ul><li><p>Java 可以通过继承来扩展接口，其一般的继承格式如下:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [访问权限符] interface 接口名称 [extends 父接口1 [, 父接口1, 父接口3 ...]] &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>一个示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IYPerson</span> <span class="keyword">extends</span>  <span class="title">IPerson</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Java编程思想</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;接口是Java提供的一种非常强大的特性，使用接口机制可以实现封装隔离，将外部调用与内部实现分割开来。&lt;br&gt;&lt;em&gt;面向接口
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="接口" scheme="http://www.shifeiqi.top/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="Interface" scheme="http://www.shifeiqi.top/tags/Interface/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://www.shifeiqi.top/2018/08/01/2018-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.shifeiqi.top/2018/08/01/2018-08-01-设计模式-单例模式/</id>
    <published>2018-08-01T06:54:10.000Z</published>
    <updated>2019-03-01T14:07:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Ensure a class has only one instance, and provide a global point of access to it.<br>确保一个类只有一个实例，并且向整个应用提供这个实例。</p><h1 id="URM"><a href="#URM" class="headerlink" title="URM"></a>URM</h1><p>单例类模板一般的定义格式如下:</p><ul><li>拥有一个静态属性用来指向单例对象。</li><li>构造方法私有化，避免其他对象创建该类实例&lt;不然叫啥单例&gt;。</li><li>提供一个公有接口提供单例对象。  </li></ul><p>具体类图如下:  </p><p><img src="/2018/08/01/2018-08-01-设计模式-单例模式/medias/images/code/java_design_pattern/singleton/singleton-pattern-urm.png" alt="单例模式-URM"></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>根据单例对象被创建的时机，单例模式的实现一般被分为以下几种：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/01/2018-08-01-设计模式-单例模式/medias/images/code/java_design_pattern/singleton/singleton-pattern-xmind.png" alt="单例模式-URM" title>                </div>                <div class="image-caption">单例模式-URM</div>            </figure><p>各种写法如下所示：</p><ul><li><p><em>饿汉写法</em> <code>(eagerly initialized singleton)</code><br>饿汉写法利用Java的类加载机制，在类加载的时候对实例进行初始化，巧妙地避开了多线程竞争导致实例初始化多次的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数，避免该类被其他对象初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共有接口，获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>懒汉写法-线程安全</em> <code>(lazily initialized singleton)</code><br>懒汉写法基于懒加载<code>(lazy loading)</code>原理，在第一次使用的时候该实例的时候才会对该实例进行实例化操作。在多线程模式下，由于多线程竞争锁会导致效率问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数，避免该类被其他对象初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共有接口，获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>懒汉写法-双检锁DCL</em> <code>(Double Check Locking)</code><br>DCL基于线程安全的懒汉模式，在一定程度上解决了多线程竞争锁导致的效率问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数，避免该类被其他对象初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共有接口，获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>懒汉写法-内部类</em><br>基于内部类的懒汉模式基于以下原理:<code>内部类第一次被使用的时候才会被Java虚拟机加载，进而去实例化内部类的类属性</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数，避免该类被其他对象初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共有接口，获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类，持有单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="noopener"><em>设计模式之禅</em></a></li><li><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener"><em>java-design-patterns</em></a></li><li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener"><em>Double-Checked Locking</em></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;Ensure a class has only one instance, and provide a global point of ac
      
    
    </summary>
    
      <category term="2018" scheme="http://www.shifeiqi.top/categories/2018/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="设计模式" scheme="http://www.shifeiqi.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="http://www.shifeiqi.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://www.shifeiqi.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis and Jedis（Lists-Java）</title>
    <link href="http://www.shifeiqi.top/2017/10/01/2017-09-29-Redis%20and%20Jedis%EF%BC%88Lists-Java%EF%BC%89/"/>
    <id>http://www.shifeiqi.top/2017/10/01/2017-09-29-Redis and Jedis（Lists-Java）/</id>
    <published>2017-10-01T01:28:25.000Z</published>
    <updated>2019-03-01T14:07:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API介绍及示例"><a href="#API介绍及示例" class="headerlink" title="API介绍及示例"></a>API介绍及示例</h1><p><code>Jedis</code>中关于<code>List</code>操作的API如下：</p><ul><li><code>Jedis.blpop(int timeout,String... keys)</code>：从左边获取并删除列表中的第一个元素，timeout表示阻塞时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 弹出名为tList的列表中的第一个元素，阻塞时间为10s</span></span><br><span class="line">List&lt;String&gt; ret1 = jedis.blpop(<span class="number">10</span>, <span class="string">"tList"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 按照顺序在l1、l2、l3三个列表中寻找一个元素并弹出。</span></span><br><span class="line"><span class="comment"> * redis首先弹出l1中的第一个元素并结束，如果l1为空，则弹出l2中的第一个元素并结束，如果l2为空，</span></span><br><span class="line"><span class="comment"> * 则弹出l3中的第一个元素并结束；如果l3为空，则进入10s阻塞时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;String&gt; ret2 = jedis.blpop(<span class="number">10</span>, <span class="string">"l1"</span>, <span class="string">"l2"</span>, <span class="string">"l3"</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>Jedis.brpop(int timeout,String... keys);</code>: 从右边获取并删除列表的第一个元素，timeout表示阻塞时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 从右边获取并删除列表list的第一个元素，阻塞时间为10s</span></span><br><span class="line">List&lt;String&gt; ret1 = jedis.brpop(<span class="number">10</span>, <span class="string">"list"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.brpoplpush(String source,String destination,int timeout)</code>：弹出并删除source中的第一个元素，将其推入到destination中，阻塞时间为timeout。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">  Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line">  <span class="comment">// 授权</span></span><br><span class="line">  jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line">  <span class="comment">// 弹出l1中的第一个元素，并将其推入到l2中，阻塞时间为5s</span></span><br><span class="line">  String ret = jedis.brpoplpush(<span class="string">"l1"</span>, <span class="string">"l2"</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.lindex(key, index)</code>: 获取列表中索引为index的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 获取l1中索引为2的元素</span></span><br><span class="line">String ret = jedis.lindex(<span class="string">"l1"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.linsert(String key,LIST_POSITION where,String pivot,String value)</code>:在列表的元素pivot之前或者之后插入value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 在列表l1中元素"hello"之前插入"word"</span></span><br><span class="line">Long ret = jedis.linsert(<span class="string">"l1"</span>, LIST_POSITION.BEFORE, <span class="string">"hello"</span>, <span class="string">"word"</span>);</span><br><span class="line"><span class="comment">// 在列表l1中的元素"hello"之后插入"word"</span></span><br><span class="line">Long ret2 = jedis.linsert(<span class="string">"l1"</span>, LIST_POSITION.AFTER, <span class="string">"hello"</span>, <span class="string">"word"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.llen(String key);</code>：获取列表长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 获取列表l1的长度</span></span><br><span class="line">Long ret = jedis.llen(<span class="string">"l1"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.lpop(String key)</code>: 从队列的左边出队一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 从队列l1的左边弹出一个元素</span></span><br><span class="line">String ret = jedis.lpop(<span class="string">"l1"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.lpush(String key,String... strings)</code>: 从队列的左边入队一个或多个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 从队列l1的左边入元素"hello"</span></span><br><span class="line"><span class="keyword">long</span> ret = jedis.lpush(<span class="string">"l1"</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.lpushx(String key,String... string);</code>: 当队列存在时，从队列的左边入队一个元素（自然当队列不存在时redis不做操作了）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">//当l1存在时，将"hello"从l1的左边入队。</span></span><br><span class="line"><span class="keyword">long</span> ret = jedis.lpushx(<span class="string">"l1"</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.lrange(String key,long start,long end);</code>: 获取队列中指定范围的元素,从左向右。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 获取l1中index从2到4的元素</span></span><br><span class="line">List&lt;String&gt; ret = jedis.lrange(<span class="string">"l1"</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.lrem(String key,long count,long value)</code>: 移除列表中的value（count参数的使用见下）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 从左往右删除2个l1中的值为"hello"的元素</span></span><br><span class="line">Long ret = jedis.lrem(<span class="string">"l1"</span>, <span class="number">2</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 从右往左删除3个l1中值为"word"的元素</span></span><br><span class="line"><span class="keyword">long</span> ret2 = jedis.lrem(<span class="string">"l1"</span>, -<span class="number">3</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 删除l1中所有的值为haha的元素</span></span><br><span class="line"><span class="keyword">long</span> ret3 = jedis.lrem(<span class="string">"l1"</span>, <span class="number">0</span>, <span class="string">"haha"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.lset(String key,long index,String value)</code>: 设置列表中下标为index(从左到右)的值,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 设置l1中下标为2的元素的值为hello</span></span><br><span class="line">String ret = jedis.lset(<span class="string">"l1"</span>, <span class="number">2</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.ltrim(String key,long start,long end)</code>: 清理列表，只保留从start到stop下标的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 清理列表l1，保留指定范围元素(2-9)。</span></span><br><span class="line">String ret = jedis.ltrim(<span class="string">"l1"</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">// 清理列表l2，保留指定范围元素(1-l2中倒数第二个元素的下标)。</span></span><br><span class="line">String ret2 = jedis.ltrim(<span class="string">"l1"</span>, <span class="number">1</span>, -<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.rpop(String key)</code>: 从队列的右边出队一个元素并删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 从队列l1的右边弹出一个元素并删除</span></span><br><span class="line">String value = jedis.rpop(<span class="string">"l1"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.rpoplpush(String srckey,String dstkey)</code>: 从source的右边出队一个元素，并将其从左边入队到destination中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 从l1的右边出队一个元素，并将其从左边入队到l2中去</span></span><br><span class="line">String ret = jedis.rpoplpush(<span class="string">"l1"</span>, <span class="string">"l2"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.rpush(String key,String... strings)</code>: 将元素从队列的右边入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 将元素hello从队列l1的右边入队</span></span><br><span class="line"><span class="keyword">long</span> ret = jedis.rpush(<span class="string">"l1"</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Jedis.rpushx(String key,String... string)</code>: 如果队列存在时，从该队列的右边入队元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 如果队列l1存在，则从l1的右边入队元素hello</span></span><br><span class="line"><span class="keyword">long</span> ret = jedis.rpushx(<span class="string">"l1"</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;API介绍及示例&quot;&gt;&lt;a href=&quot;#API介绍及示例&quot; class=&quot;headerlink&quot; title=&quot;API介绍及示例&quot;&gt;&lt;/a&gt;API介绍及示例&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Jedis&lt;/code&gt;中关于&lt;code&gt;List&lt;/code&gt;操作的API如下
      
    
    </summary>
    
      <category term="2017" scheme="http://www.shifeiqi.top/categories/2017/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="Redis" scheme="http://www.shifeiqi.top/tags/Redis/"/>
    
      <category term="Jedis" scheme="http://www.shifeiqi.top/tags/Jedis/"/>
    
      <category term="NoSql" scheme="http://www.shifeiqi.top/tags/NoSql/"/>
    
      <category term="内存数据库" scheme="http://www.shifeiqi.top/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Key-Value" scheme="http://www.shifeiqi.top/tags/Key-Value/"/>
    
  </entry>
  
  <entry>
    <title>Redis and Jedis（Lists-Command）</title>
    <link href="http://www.shifeiqi.top/2017/10/01/2017-09-29-Redis%20and%20Jedis%EF%BC%88Lists-Command%EF%BC%89/"/>
    <id>http://www.shifeiqi.top/2017/10/01/2017-09-29-Redis and Jedis（Lists-Command）/</id>
    <published>2017-10-01T01:28:25.000Z</published>
    <updated>2019-03-01T14:07:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Command介绍"><a href="#Command介绍" class="headerlink" title="Command介绍"></a>Command介绍</h1><p><code>Redis</code>中关于<code>List</code>的命令如下：</p><ul><li><p><code>BLPOP key [key...] timeout</code>： 获取并删除列表中的第一个元素，timeout表示阻塞时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>弹出名为tList的列表中的第一个元素，阻塞时间为10s</span><br><span class="line">BLPOP tList 10</span><br><span class="line"><span class="meta">#</span>按照顺序在l1、l2、l3三个列表中寻找一个元素并弹出。</span><br><span class="line"><span class="meta">#</span>redis首先弹出l1中的第一个元素并结束，如果l1为空，则弹出l2中的第一个元素并结束，如果l2为空，</span><br><span class="line"><span class="meta">#</span>则弹出l3中的第一个元素并结束；如果l3为空，则进入10s阻塞时间。</span><br><span class="line">BLPOP l1 l2 l3 10</span><br></pre></td></tr></table></figure></li><li><p><code>BRPOP key [key...] timeout</code>: 获取并删除列表的最后一个元素，timeout表示阻塞时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>弹出名为list的列表中的最后一个元素，阻塞时间为10s</span><br><span class="line">BRPOP list 10</span><br></pre></td></tr></table></figure></li><li><p><code>BRPOPLPUSH source destination timeout</code>：弹出并删除source中的第一个元素，将其推入到destination中，阻塞时间为timeout。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>弹出l1中的第一个元素，并将其推入到l2中，阻塞时间为5s</span><br><span class="line">BRPOPLPUSH l1 l2 5</span><br></pre></td></tr></table></figure></li><li><p><code>LINDEX key index</code>: 获取列表中索引为index的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>获取l1中索引为2的元素</span><br><span class="line">LINDEX l1 2</span><br></pre></td></tr></table></figure></li><li><p><code>LINSERT key BEFORE|AFTER pivot value</code>:在列表的元素pivot之前或者之后插入value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>在列表l1中元素"hello"之前插入"word"</span><br><span class="line">LINSERT l1 BEFORE "hello" "word"</span><br><span class="line"><span class="meta">#</span>在列表l1中的元素"hello"之后插入"word"</span><br><span class="line">LINSERT l1 AFTER "hello" "word"</span><br></pre></td></tr></table></figure></li><li><p><code>LLEN</code>：获取列表长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>获取列表l1的长度</span><br><span class="line">LLEN l1</span><br></pre></td></tr></table></figure></li><li><p><code>LPOP key</code>: 从队列的左边出队一个元素。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>从队列l1的左边弹出一个元素</span><br><span class="line">LPOP l1</span><br></pre></td></tr></table></figure></li><li><p><code>LPUSH key value [value ...]</code>: 从队列的左边入队一个或多个元素。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>从队列l1的左边入元素"hello"</span><br><span class="line">LPUSH l1 hello</span><br></pre></td></tr></table></figure></li><li><p><code>LPUSHX key value</code>: 当队列存在时，从队列的左边入队一个元素（自然当队列不存在时redis不做操作了）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>当l1存在时，将"hello"从l1的左边入队。</span><br><span class="line">LPUSHX l1 hello</span><br></pre></td></tr></table></figure></li><li><p><code>LRANGE key statrt stop</code>: 获取队列中指定范围的元素。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>获取l1中index从2到4的元素</span><br><span class="line">LRANGE l1 2 4</span><br></pre></td></tr></table></figure></li><li><p><code>LREM key count value</code>: 移除列表中的value（count参数的使用见下）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>从左往右删除2个l1中的值为"hello"的元素</span><br><span class="line">LREM l1 2 hello</span><br><span class="line"><span class="meta">#</span>从右往左删除3个l1中值为"word"的元素</span><br><span class="line">LREM l1 -3 word</span><br><span class="line"><span class="meta">#</span>删除l1中所有的值为haha的元素</span><br><span class="line">LREM l1 0 haha</span><br></pre></td></tr></table></figure></li><li><p><code>LSET key index value</code>: 设置列表中下标为index的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>设置l1中下标为2的元素的值为hello</span><br><span class="line">LSET l1 2 hello</span><br></pre></td></tr></table></figure></li><li><p><code>LTRIM key start stop</code>: 清理列表，只保留从start到stop下标的元素。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>清理列表l1，保留指定范围元素(2-9)。</span><br><span class="line">LTRIM l1 2 9</span><br><span class="line"><span class="meta">#</span>清理列表l2，保留指定范围元素(1-l2中倒数第二个元素的下标)。</span><br><span class="line">LTRIM l2 1 -2</span><br></pre></td></tr></table></figure></li><li><p><code>RPOP key</code>: 从队列的右边出队一个元素并删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>从队列l1的右边弹出一个元素并删除</span><br><span class="line">RPOP l1</span><br></pre></td></tr></table></figure></li><li><p><code>RPOPLPUSH source destination</code>: 从source的右边出队一个元素，并将其从左边入队到destination中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>从l1的右边出队一个元素，并将其从左边入队到l2中去</span><br><span class="line">RPOPLPUSH l1 l2</span><br></pre></td></tr></table></figure></li><li><p><code>RPUSH key value [value...]</code>: 将元素从队列的右边入队。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>将元素hello从队列l1的右边入队</span><br><span class="line">RPUSH l1 hello</span><br></pre></td></tr></table></figure></li><li><p><code>RPUSHX key value</code>: 如果队列存在时，从该队列的右边入队元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>如果队列l1存在，则从l1的右边入队元素hello</span><br><span class="line">RPUSHX l1 hello</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://redis.cn/commands.html#list" target="_blank" rel="noopener">Redis官方资料</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Command介绍&quot;&gt;&lt;a href=&quot;#Command介绍&quot; class=&quot;headerlink&quot; title=&quot;Command介绍&quot;&gt;&lt;/a&gt;Command介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;中关于&lt;code&gt;List&lt;/code&gt;的命令如
      
    
    </summary>
    
      <category term="2017" scheme="http://www.shifeiqi.top/categories/2017/"/>
    
    
      <category term="Redis" scheme="http://www.shifeiqi.top/tags/Redis/"/>
    
      <category term="Jedis" scheme="http://www.shifeiqi.top/tags/Jedis/"/>
    
      <category term="NoSql" scheme="http://www.shifeiqi.top/tags/NoSql/"/>
    
      <category term="内存数据库" scheme="http://www.shifeiqi.top/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Key-Value" scheme="http://www.shifeiqi.top/tags/Key-Value/"/>
    
      <category term="Command" scheme="http://www.shifeiqi.top/tags/Command/"/>
    
  </entry>
  
  <entry>
    <title>Redis and Jedis（key生存时间管理-Java）</title>
    <link href="http://www.shifeiqi.top/2017/09/30/2017-09-29-Redis%20and%20Jedis%EF%BC%88key%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-Java%EF%BC%89/"/>
    <id>http://www.shifeiqi.top/2017/09/30/2017-09-29-Redis and Jedis（key生存时间管理-Java）/</id>
    <published>2017-09-30T08:47:15.000Z</published>
    <updated>2019-03-01T14:07:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><p>与Redis客户端Command向对应，Jedis关于key生存时间管理的API有下面几个：</p><ul><li><code>Jedis.expire(key, seconds)</code>：设置key的过期时间，以秒为单位。</li><li><code>Jedis.pexpire(key, milliseconds)</code>：设置key的过期时间，以毫秒为单位。</li><li><code>Jedis.expireAt(key, unixTime)</code>：设置key的过期时间，时间参数为Unix时间戳（从1970年1月1日开始经过的秒数）。</li><li><code>Jedis.pexpireAt(key, millisecondsTimestamp)</code>:设置key的过期时间，时间参数为Unix时间戳，以毫秒计。</li><li><code>Jedis.ttl(key)</code>: 返回key的剩余过期时间。</li><li><code>Jedis.pttl(key)</code>: 返回key的剩余过期时间，以毫秒计。</li><li><code>Jedis.persist(key)</code>：移除key的过期时间。</li></ul><h1 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h1><ul><li>设置<code>appleKey</code>的过期时间为60s。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 设置appleKey的过期时间为60s，以秒的方式</span></span><br><span class="line">jedis.expire(<span class="string">"appleKey"</span>, <span class="number">60</span>);</span><br><span class="line"><span class="comment">// 设置appleKey的过期时间为60s,以毫秒的方式</span></span><br><span class="line">jedis.pexpire(<span class="string">"appleKey"</span>, <span class="number">60000</span>);</span><br></pre></td></tr></table></figure><ul><li>返回<code>appleKey</code>的剩余时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 返回appleKey的剩余时间，以秒的方式</span></span><br><span class="line"><span class="keyword">long</span> time = jedis.ttl(<span class="string">"appleKey"</span>);</span><br><span class="line"><span class="comment">// 返回appleKey的剩余时间，以毫秒的方式</span></span><br><span class="line"><span class="keyword">long</span> milliTime = jedis.pttl(<span class="string">"appleKey"</span>);</span><br></pre></td></tr></table></figure><ul><li>移除appleKey的过期时间（使appleKey永久存在）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 移除appleKey的过期时间</span></span><br><span class="line">jedis.persist(<span class="string">"appleKey"</span>);</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;API介绍&quot;&gt;&lt;a href=&quot;#API介绍&quot; class=&quot;headerlink&quot; title=&quot;API介绍&quot;&gt;&lt;/a&gt;API介绍&lt;/h1&gt;&lt;p&gt;与Redis客户端Command向对应，Jedis关于key生存时间管理的API有下面几个：&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="2017" scheme="http://www.shifeiqi.top/categories/2017/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="Redis" scheme="http://www.shifeiqi.top/tags/Redis/"/>
    
      <category term="Jedis" scheme="http://www.shifeiqi.top/tags/Jedis/"/>
    
      <category term="NoSql" scheme="http://www.shifeiqi.top/tags/NoSql/"/>
    
      <category term="内存数据库" scheme="http://www.shifeiqi.top/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Key-Value" scheme="http://www.shifeiqi.top/tags/Key-Value/"/>
    
  </entry>
  
  <entry>
    <title>Redis and Jedis（key生存时间管理-Command）</title>
    <link href="http://www.shifeiqi.top/2017/09/30/2017-09-29-Redis%20and%20Jedis%EF%BC%88key%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-Command%EF%BC%89/"/>
    <id>http://www.shifeiqi.top/2017/09/30/2017-09-29-Redis and Jedis（key生存时间管理-Command）/</id>
    <published>2017-09-30T06:29:12.000Z</published>
    <updated>2019-03-01T14:07:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Command-介绍"><a href="#Command-介绍" class="headerlink" title="Command 介绍"></a>Command 介绍</h1><p>在Redis中的key是具备生存时间的，一般一个key的默认生存时间是永久存在的（你要是不开心删掉它那就另说了。。。）。当然你也可以对key的生存时间进行设置。与key的生存时间相关的Command有如下几个：</p><ul><li><code>EXPIRE key seconds</code>：设置key的过期时间，以秒为单位。</li><li><code>PEXPIRE key milliseconds</code>：设置key的过期时间，以毫秒为单位。</li><li><code>EXPIREAT key timestamp</code>：设置key的过期时间，时间参数为Unix时间戳（从1970年1月1日开始经过的秒数）。</li><li><code>PEXPIREAT key millisecondes-timestamp</code>:设置key的过期时间，时间参数为Unix时间戳，以毫秒计。</li><li><code>TTL key</code>: 返回key的剩余过期时间。</li><li><code>PTTL key</code>: 返回key的剩余过期时间，以毫秒计。</li><li><code>PERSIST key</code>：移除key的过期时间。</li></ul><h1 id="Command使用"><a href="#Command使用" class="headerlink" title="Command使用"></a>Command使用</h1><ul><li>设置<code>appleKey</code>的过期时间为60s。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE appleKey 60 #以秒的方式</span><br><span class="line">PEXPIRE appleKey 60000 #以毫秒的方式</span><br></pre></td></tr></table></figure><ul><li>返回appleKey的剩余过期时间</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TTL appleKey #以秒的方式</span><br><span class="line">PTTL appleKey #以毫秒的方式</span><br></pre></td></tr></table></figure><ul><li>移除appleKey的过期时间（使appleKey永久存在）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERSIST appleKey #移除appleKey的过期时间</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">Redis官方资料</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Command-介绍&quot;&gt;&lt;a href=&quot;#Command-介绍&quot; class=&quot;headerlink&quot; title=&quot;Command 介绍&quot;&gt;&lt;/a&gt;Command 介绍&lt;/h1&gt;&lt;p&gt;在Redis中的key是具备生存时间的，一般一个key的默认生存时间是永久存
      
    
    </summary>
    
      <category term="2017" scheme="http://www.shifeiqi.top/categories/2017/"/>
    
    
      <category term="Redis" scheme="http://www.shifeiqi.top/tags/Redis/"/>
    
      <category term="Jedis" scheme="http://www.shifeiqi.top/tags/Jedis/"/>
    
      <category term="NoSql" scheme="http://www.shifeiqi.top/tags/NoSql/"/>
    
      <category term="内存数据库" scheme="http://www.shifeiqi.top/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Key-Value" scheme="http://www.shifeiqi.top/tags/Key-Value/"/>
    
      <category term="Command" scheme="http://www.shifeiqi.top/tags/Command/"/>
    
  </entry>
  
  <entry>
    <title>Redis and Jedis（事务管理-Java）</title>
    <link href="http://www.shifeiqi.top/2017/09/29/2017-09-29-Redis%20and%20Jedis%EF%BC%88%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-Java%EF%BC%89/"/>
    <id>http://www.shifeiqi.top/2017/09/29/2017-09-29-Redis and Jedis（事务管理-Java）/</id>
    <published>2017-09-29T10:20:32.000Z</published>
    <updated>2019-03-01T14:07:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h1><p>Jedis中与Redis事务相关一共有两个类:<code>Jedis</code>和<code>Transaction</code>，相关API如下：</p><ol><li><code>Jedis.multi()</code>：标志着事务的开始，从<code>Jedis.multi</code>开始到<code>Transaction.exec()</code>（或者<code>Transaction.discard()</code>）之间的代码会被Redis服务器作为原子操作执行。返回值为<code>OK</code>。</li><li><code>Transaction.exec()</code>：事务提交执行，和<code>Jedis.multi()</code>成对出现。</li><li><code>Transaction.discard()</code>：事务回滚，和<code>Jedis.multi()</code>成对出现。返回值为<code>OK</code>。</li><li><code>Jedis.watch(String...keys)</code>：监视一个（多个）key，从<code>Jedis.watch(String...keys)</code>执行结束到<code>MULTI</code>命令执行开始的时间段中，如果这些key被其他客户端改动，事务将被打断以致执行失败。</li><li><code>Jedis.unwatch()</code>：取消<code>Jedis.watch(String...keys)</code>所标志的所有的key的监视。</li></ol><h1 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h1><ul><li>事务提交</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">Transaction transaction = jedis.multi();</span><br><span class="line"><span class="comment">// 操作Redis</span></span><br><span class="line">transaction.set(<span class="string">"appleKey"</span>, <span class="string">"appleValue"</span>);</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">transaction.exec();</span><br></pre></td></tr></table></figure><ul><li>事务回滚</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">Transaction transaction = jedis.multi();</span><br><span class="line"><span class="comment">// 操作Redis</span></span><br><span class="line">transaction.set(<span class="string">"appleKey"</span>, <span class="string">"appleValue"</span>);</span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line">transaction.discard();</span><br></pre></td></tr></table></figure><ul><li>监视keys</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 监听keys，从jedis.watch()开始到transaction.multi()执行的这段时间，</span></span><br><span class="line"><span class="comment">// 如果有其他客户端对appleKey进行操作，则该事务会被打断</span></span><br><span class="line">jedis.watch(<span class="string">"appleKey"</span>);</span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">Transaction transaction = jedis.multi();</span><br><span class="line"><span class="comment">// 操作Redis</span></span><br><span class="line">transaction.set(<span class="string">"appleKey"</span>, <span class="string">"appleValue"</span>);</span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line">transaction.exec();</span><br></pre></td></tr></table></figure><ul><li>取消keys监视</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Redis客户端实例</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"10.1.10.53"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 授权</span></span><br><span class="line">jedis.auth(<span class="string">"redis"</span>);</span><br><span class="line"><span class="comment">// 监听keys</span></span><br><span class="line">jedis.watch(<span class="string">"appleKey"</span>,<span class="string">"androidKey"</span>);</span><br><span class="line"><span class="comment">// 取消监视keys,从当前时间开始到 jedis.multi() 被执行的时间段中，</span></span><br><span class="line"><span class="comment">// 其他客户端对appleKey或者androidKey的操作将不会影响该事务的执行。</span></span><br><span class="line">jedis.unwatch();</span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">Transaction transaction = jedis.multi();</span><br><span class="line"><span class="comment">// 操作Redis</span></span><br><span class="line">transaction.set(<span class="string">"appleKey"</span>, <span class="string">"appleValue"</span>);</span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line">transaction.exec();</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;API-介绍&quot;&gt;&lt;a href=&quot;#API-介绍&quot; class=&quot;headerlink&quot; title=&quot;API 介绍&quot;&gt;&lt;/a&gt;API 介绍&lt;/h1&gt;&lt;p&gt;Jedis中与Redis事务相关一共有两个类:&lt;code&gt;Jedis&lt;/code&gt;和&lt;code&gt;Transa
      
    
    </summary>
    
      <category term="2017" scheme="http://www.shifeiqi.top/categories/2017/"/>
    
    
      <category term="JAVA" scheme="http://www.shifeiqi.top/tags/JAVA/"/>
    
      <category term="Redis" scheme="http://www.shifeiqi.top/tags/Redis/"/>
    
      <category term="Jedis" scheme="http://www.shifeiqi.top/tags/Jedis/"/>
    
      <category term="NoSql" scheme="http://www.shifeiqi.top/tags/NoSql/"/>
    
      <category term="内存数据库" scheme="http://www.shifeiqi.top/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Key-Value" scheme="http://www.shifeiqi.top/tags/Key-Value/"/>
    
  </entry>
  
  <entry>
    <title>Redis and Jedis（事务管理-Command）</title>
    <link href="http://www.shifeiqi.top/2017/09/29/2017-09-29-Redis%20and%20Jedis%EF%BC%88%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-Command%EF%BC%89/"/>
    <id>http://www.shifeiqi.top/2017/09/29/2017-09-29-Redis and Jedis（事务管理-Command）/</id>
    <published>2017-09-29T08:27:30.000Z</published>
    <updated>2019-03-01T14:07:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Command介绍"><a href="#Command介绍" class="headerlink" title="Command介绍"></a>Command介绍</h1><p>从<a href="https://redis.io/commands#transactions" target="_blank" rel="noopener">官方文档</a>中可以看到，Redis关于事务管理方面的命令一共5个，各个命令及所代表的含义如下：</p><ol><li><code>MULTI</code>：标志着事务的开始，从<code>MULTI</code>开始到<code>EXEC</code>（或者<code>DISCARD</code>）之间的命令会被Redis服务器作为原子操作执行。返回值为<code>OK</code>。</li><li><code>EXEC</code>: 事务提交执行，和<code>MULTI</code>成对出现。</li><li><code>DISCARD</code>: 事务回滚，和<code>MULTI</code>成对出现。返回值为<code>OK</code>。</li><li><code>WATCH key[key...]</code>:监视一个（多个）key，从<code>WATCH</code>命令执行结束到<code>MULTI</code>命令执行开始的时间段中，如果这些key被其他客户端改动，事务将被打断以致执行失败。</li><li><code>UNWATCH</code>: 取消<code>WATCH</code>所标志的所有的key的监视。</li></ol><h1 id="Command操作"><a href="#Command操作" class="headerlink" title="Command操作"></a>Command操作</h1><ul><li>事务提交</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MULTI #开启事务</span><br><span class="line">SET KEY "VALUE"#操作Redis</span><br><span class="line">EXEC #提交事务</span><br></pre></td></tr></table></figure><ul><li>事务回滚</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MULTI #开启事务</span><br><span class="line">SET KEY "VALUE"#操作Redis</span><br><span class="line">DISCARD #回滚事务</span><br></pre></td></tr></table></figure><ul><li>监视keys</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH appleKey #监视一个名为appleKey的key</span><br><span class="line"><span class="meta">#</span>从当前时间开始到 MULTI 命令被执行的时间里如果有其他的客户端对appleKey进行修改，则下面的事务将会被打断#</span><br><span class="line"></span><br><span class="line">MULTI #开启事务</span><br><span class="line">SET appleKey "VALUE"#操作Redis</span><br><span class="line">EXEC #提交事务，如果事务被打断将返回 nil</span><br></pre></td></tr></table></figure><ul><li>取消keys监视</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WATCH appleKey androidKey #监视一个名为appleKey的key</span><br><span class="line">UNWATCH #取消对appleKey和androidKey的监视</span><br><span class="line"><span class="meta">#</span>从当前时间开始到 MULTI 命令被执行的时间段中，其他客户端对appleKey或者androidKey的操作将不会影响事务的执行#</span><br><span class="line"></span><br><span class="line">MULTI #开启事务</span><br><span class="line">SET appleKey "VALUE"#操作Redis</span><br><span class="line">EXEC #提交事务</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://redis.io/commands#transactions" target="_blank" rel="noopener">Redis官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Command介绍&quot;&gt;&lt;a href=&quot;#Command介绍&quot; class=&quot;headerlink&quot; title=&quot;Command介绍&quot;&gt;&lt;/a&gt;Command介绍&lt;/h1&gt;&lt;p&gt;从&lt;a href=&quot;https://redis.io/commands#transa
      
    
    </summary>
    
      <category term="2017" scheme="http://www.shifeiqi.top/categories/2017/"/>
    
    
      <category term="Redis" scheme="http://www.shifeiqi.top/tags/Redis/"/>
    
      <category term="Jedis" scheme="http://www.shifeiqi.top/tags/Jedis/"/>
    
      <category term="NoSql" scheme="http://www.shifeiqi.top/tags/NoSql/"/>
    
      <category term="内存数据库" scheme="http://www.shifeiqi.top/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Key-Value" scheme="http://www.shifeiqi.top/tags/Key-Value/"/>
    
      <category term="Command" scheme="http://www.shifeiqi.top/tags/Command/"/>
    
  </entry>
  
</feed>
